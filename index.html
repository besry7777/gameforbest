<!DOCTYPE html>
<html lang="th">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
   <title>Super XO Game</title>
   <script src="https://cdn.tailwindcss.com"></script>
   <link rel="preconnect" href="https://fonts.googleapis.com">
   <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
   <link href="https://fonts.googleapis.com/css2?family=Kanit:wght@400;600;700&display=swap" rel="stylesheet">
   <style>
       /* CSS for Loading Screen */
       .loader-overlay {
           position: fixed;
           inset: 0;
           background-color: rgba(255, 255, 255, 0.9);
           display: flex;
           justify-content: center;
           align-items: center;
           z-index: 9999;
           transition: opacity 0.3s ease-in-out;
       }
       .loader {
           border: 8px solid #f3f3f3; /* Light grey */
           border-top: 8px solid #3b82f6; /* Blue */
           border-radius: 50%;
           width: 60px;
           height: 60px;
           animation: spin 1s linear infinite;
       }
       @keyframes spin {
           0% { transform: rotate(0deg); }
           100% { transform: rotate(360deg); }
       }

       :root {
           --x-color: #ef4444; /* red-500 */
           --o-color: #3b82f6; /* blue-500 */
       }
       body { font-family: 'Kanit', sans-serif; -webkit-tap-highlight-color: transparent; touch-action: manipulation; }
       .screen, .modal-overlay { display: none; }
       .screen.active, .modal-overlay.active { display: flex; }
       .input-field { @apply w-full px-4 py-3 mb-4 text-center bg-gray-100 border-2 border-gray-300 rounded-lg focus:outline-none focus:border-blue-500 transition-colors; }
       .button { @apply w-full max-w-sm px-4 py-3 my-2 text-lg font-semibold text-white transition-transform duration-150 ease-in-out rounded-lg shadow-md transform active:scale-95 flex justify-center items-center gap-2; }
       .button:disabled { @apply opacity-50 cursor-not-allowed; }
       .button-primary { @apply bg-gradient-to-br from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700; }
       .button-secondary { @apply bg-gradient-to-br from-gray-500 to-gray-600 hover:from-gray-600 hover:to-gray-700; }
       .button-success { @apply bg-gradient-to-br from-green-500 to-green-600 hover:from-green-600 hover:to-green-700; }
       .button-danger { @apply bg-gradient-to-br from-red-500 to-red-600 hover:from-red-600 hover:to-red-700; }
       .cell {
           position: relative;
           display: flex;
           justify-content: center;
           align-items: center;
           font-size: clamp(3rem, 18vmin, 7rem);
           font-weight: bold;
           cursor: pointer;
           border: 2px solid #e5e7eb; /* gray-200 */
           transition: background-color 0.2s;
           line-height: 1; /* Prevents text from affecting cell height */
       }
       .cell:hover { background-color: #f9fafb; /* gray-50 */ }
       .cell.x { color: var(--x-color); }
       .cell.o { color: var(--o-color); }
       .cell.fading { animation: fadeOut 0.5s forwards; }
       @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
       .cell.indicate-fade {
           animation: pulseFade 1.5s infinite;
       }
       @keyframes pulseFade { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
       #game-board {
           display: grid;
           grid-template-columns: repeat(3, 1fr);
           width: 90vw;
           height: 90vw;
           max-width: 450px;
           max-height: 450px;
           aspect-ratio: 1 / 1;
           position: relative;
       }
       .context-menu {
           position: absolute;
           display: none;
           z-index: 1000;
       }
       .winning-line {
           position: absolute;
           background-color: rgba(255, 215, 0, 0.8);
           height: 12px;
           border-radius: 6px;
           transform-origin: top left;
           animation: drawLine 0.5s ease-out forwards;
       }
       @keyframes drawLine {
           from { width: 0; }
           to { width: var(--line-width); }
       }
   </style>
</head>
<body class="bg-gray-50 text-gray-800">

   <div id="loading-overlay" class="loader-overlay">
       <div class="loader"></div>
   </div>
   
   <div id="connection-error-overlay" class="screen fixed inset-0 bg-white flex-col justify-center items-center p-5 text-center" style="z-index: 9998; display: none;">
       <h2 class="text-2xl font-bold text-red-500 mb-4">เกิดข้อผิดพลาดในการเชื่อมต่อ</h2>
       <p class="text-lg mb-6">ไม่สามารถเชื่อมต่อกับเซิร์ฟเวอร์ได้<br>กรุณาตรวจสอบการเชื่อมต่ออินเทอร์เน็ตแล้วลองใหม่อีกครั้ง</p>
       <button onclick="window.location.reload()" class="button button-primary">โหลดใหม่</button>
   </div>

   <canvas id="confetti-canvas" class="fixed top-0 left-0 w-full h-full pointer-events-none" style="z-index: 9997;"></canvas>

   <div id="toast-notification" class="fixed top-5 right-5 bg-gray-800 text-white px-6 py-3 rounded-lg shadow-lg opacity-0 transform -translate-y-10 transition-all duration-300 z-50">
       <p id="toast-message"></p>
   </div>

   <div id="context-menu" class="context-menu bg-white rounded-md shadow-lg overflow-hidden border border-gray-200">
       <button id="view-profile-ctx-btn" class="flex items-center gap-2 text-left w-full px-4 py-2 text-gray-700 hover:bg-gray-100">
           <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>
           <span>ดูโปรไฟล์</span>
       </button>
   </div>
   
   <div id="profile-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-60 justify-center items-center p-4">
       <div class="modal-content bg-white p-6 rounded-xl shadow-2xl w-full max-w-md relative">
            <button id="close-profile-btn" class="absolute top-2 right-4 text-3xl font-bold text-gray-400 hover:text-gray-700">×</button>
           <h2 id="profile-username" class="text-3xl font-bold mb-4 text-center"></h2>
           <div class="text-xl text-center space-y-1">
               <p class="font-semibold text-gray-700">สถิติ (ออนไลน์)</p>
               <p class="text-green-500">ชนะ: <span id="profile-wins" class="font-bold">0</span></p>
               <p class="text-red-500">แพ้: <span id="profile-losses" class="font-bold">0</span></p>
           </div>
       </div>
   </div>

   <main id="app-container" class="w-full h-screen overflow-hidden">
       <div id="main-menu" class="screen w-full h-full flex-col justify-center items-center p-5 text-center">
           <h1 class="text-5xl font-bold mb-2">Super XO</h1>
           <h2 id="welcome-message" class="text-2xl mb-8"></h2>
           <button id="play-bot-btn" class="button button-primary">
               <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 8V4H8"></path><rect x="4" y="12" width="16" height="8" rx="2"></rect><path d="M2 14h2"></path><path d="M20 14h2"></path><path d="M15 18v-2a2 2 0 0 0-2-2h-2a2 2 0 0 0-2 2v2Z"></path></svg>
               <span>เล่นกับบอท</span>
           </button>
           <button id="play-coop-btn" class="button button-success">
               <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>
               <span>เล่นกับเพื่อน (Online)</span>
           </button>
           <button id="settings-btn" class="button button-secondary">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
               <span>ตั้งค่า & เพื่อน</span>
           </button>
       </div>

       <div id="settings-screen" class="screen w-full h-full flex-col justify-start items-center p-5 overflow-y-auto">
           <h2 class="text-3xl font-bold my-6 text-center w-full">ตั้งค่า & เพื่อน</h2>
           
           <div class="w-full max-w-lg mx-auto bg-white p-6 rounded-lg shadow-md mb-6">
               <h3 class="text-xl font-semibold mb-2">เปลี่ยนชื่อผู้ใช้</h3>
               <input type="text" id="change-username-input" class="input-field" placeholder="อังกฤษ/ตัวเลข, 3-12 ตัว" maxlength="12">
                <p id="change-username-error" class="text-red-500 mb-2 h-5 text-sm"></p>
               <button id="save-settings-btn" class="button button-primary !w-auto !px-6 !py-2 !text-base">บันทึกชื่อใหม่</button>
           </div>

           <div class="w-full max-w-lg mx-auto bg-white p-6 rounded-lg shadow-md">
               <h3 class="text-xl font-semibold mb-2">จัดการเพื่อน</h3>
               <div class="mb-4">
                   <label for="search-user-input" class="font-semibold">ค้นหาผู้เล่น (ค้นหาเฉพาะชื่อ):</label>
                   <div class="flex mt-1">
                       <input type="text" id="search-user-input" class="input-field !mb-0 !rounded-r-none" placeholder="ค้นหาด้วยชื่อ...">
                       <button id="search-user-btn" class="bg-blue-500 text-white px-4 rounded-r-lg hover:bg-blue-600 flex-shrink-0">ค้นหา</button>
                   </div>
                   <div id="search-results" class="mt-2"></div>
               </div>
               <div id="friend-requests" class="mb-4">
                   <h4 class="font-semibold">คำขอเป็นเพื่อน:</h4>
                   <div id="friend-requests-list" class="text-gray-600">ไม่มีคำขอ</div>
               </div>
               <div>
                   <h4 class="font-semibold">รายชื่อเพื่อน:</h4>
                   <div id="friends-list" class="text-gray-600">ยังไม่มีเพื่อน</div>
               </div>
           </div>

           <button id="back-to-main-from-settings-btn" class="button button-secondary mx-auto mt-6">กลับเมนูหลัก</button>
       </div>

       <div id="coop-menu" class="screen w-full h-full flex-col justify-center items-center p-5">
           <h2 class="text-3xl font-bold mb-8">เล่นกับเพื่อน</h2>
           <button id="create-room-btn" class="button button-primary">สร้างห้อง</button>
           <input type="text" id="room-code-input" class="input-field max-w-sm" placeholder="ใส่รหัสห้อง" style="text-transform: uppercase;">
           <button id="join-room-btn" class="button button-success">เข้าร่วมห้อง</button>
           <button id="back-to-main-from-coop-btn" class="button button-secondary">กลับ</button>
       </div>

       <div id="room-lobby" class="screen w-full h-full flex-col justify-center items-center p-5 text-center">
           <h2 class="text-2xl mb-2">รหัสห้อง:</h2>
            <div class="flex items-center justify-center gap-2 mb-6">
               <span id="room-code-display" class="text-4xl font-bold text-red-500 tracking-widest"></span>
               <button id="copy-room-code-btn" class="bg-gray-200 p-2 rounded-md hover:bg-gray-300">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
               </button>
           </div>
           <div id="player-list" class="text-xl mb-6 space-y-2 w-full max-w-sm"></div>
           <p id="lobby-status" class="mb-6 h-12 text-2xl flex justify-center items-center"></p>
           <button id="ready-btn" class="button button-success">เตรียมพร้อม</button>
           <button id="leave-room-btn" class="button button-danger">ออกจากห้อง</button>
       </div>
       
       <div id="game-screen" class="screen w-full h-full flex-col justify-center items-center p-2 sm:p-5">
           <div id="turn-display" class="text-2xl font-semibold mb-4 h-8"></div>
           <div id="game-board-container" class="relative">
               <div id="game-board"></div>
               <div id="winning-line-container" class="absolute top-0 left-0 w-full h-full pointer-events-none"></div>
           </div>
           
           <div id="game-screen-over-overlay" class="absolute inset-0 bg-white/80 backdrop-blur-sm flex-col justify-center items-center text-center p-5 hidden">
                <h2 id="game-over-message" class="text-4xl font-bold mb-8"></h2>
                <button id="restart-game-btn" class="button button-primary">เล่นอีกครั้ง</button>
                <button id="back-to-menu-from-game-btn" class="button button-secondary">กลับเมนูหลัก</button>
           </div>

           <button id="leave-game-btn" class="button button-danger mt-6">ยอมแพ้/ออกจากเกม</button>
       </div>
   </main>
   
   <script type="module">
       // Firebase Imports
       import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
       import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
       import { getFirestore, doc, getDoc, setDoc, updateDoc, collection, query, where, getDocs, onSnapshot, writeBatch, runTransaction, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

       // --- Firebase Config & Initialization ---
       const firebaseConfig = {
           apiKey: "AIzaSyBcxVAP08XMiPMoqElaKM7AYY_2z08oWok",
           authDomain: "xobybestry777.firebaseapp.com",
           projectId: "xobybestry777",
           storageBucket: "xobybestry777.firebasestorage.app",
           messagingSenderId: "380539937989",
           appId: "1:380539937989:web:48049ed77f45327e033cac",
           measurementId: "G-YZWTKXL285"
       };
       const app = initializeApp(firebaseConfig);
       const auth = getAuth(app);
       const db = getFirestore(app);

       // --- Game Constants ---
       const CONST = {
           MAX_MOVE_HISTORY: 6,
           USER_TAG_LENGTH: 5,
           ROOM_CODE_LENGTH: 4,
           CONNECTION_TIMEOUT: 15000 // 15 seconds
       };
       
       // --- Audio & Animation ---
       let audioCtx;
       const confettiCanvas = document.getElementById('confetti-canvas');
       const confettiCtx = confettiCanvas.getContext('2d');
       let confettiParticles = [];
       const confettiColors = ['#ef4444', '#3b82f6', '#22c55e', '#f97316', '#eab308'];
       let animationFrameId;
       const GRAVITY = 0.08;
       const DAMPING = 0.99;
       const PARTICLE_COUNT = 150; // Optimized particle count

       const playPopSound = () => {
           if (!audioCtx) return;
           const oscillator = audioCtx.createOscillator();
           const gainNode = audioCtx.createGain();
           oscillator.type = 'sine';
           oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
           gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
           gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
           oscillator.connect(gainNode);
           gainNode.connect(audioCtx.destination);
           oscillator.start();
           oscillator.stop(audioCtx.currentTime + 0.3);
       };

       const initializeAudio = () => {
           if (!audioCtx) {
               audioCtx = new (window.AudioContext || window.webkitAudioContext)();
           }
       };
       document.body.addEventListener('click', initializeAudio, { once: true });
       
       function resizeCanvas() {
           if (!confettiCanvas) return;
           confettiCanvas.width = window.innerWidth;
           confettiCanvas.height = window.innerHeight;
       }
       window.addEventListener('resize', resizeCanvas);

       function createConfetti(origin) {
           const { width, height } = confettiCanvas;
           for (let i = 0; i < PARTICLE_COUNT; i++) {
               const angle = Math.random() * Math.PI * 2;
               const speed = Math.random() * 8 + 2; // Initial burst speed
               confettiParticles.push({
                   x: origin.x,
                   y: origin.y,
                   isCircle: Math.random() > 0.5,
                   size: Math.random() * 8 + 4,
                   color: confettiColors[Math.floor(Math.random() * confettiColors.length)],
                   vx: Math.cos(angle) * speed,
                   vy: Math.sin(angle) * speed - 2, // Add a slight upward boost
                   angle: Math.random() * Math.PI * 2,
                   spin: Math.random() * 0.2 - 0.1,
                   opacity: 1,
               });
           }
       }

       function drawConfetti() {
           if (!confettiCtx) return;
           confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
           confettiParticles.forEach((p, i) => {
               p.vy += GRAVITY;
               p.vx *= DAMPING;
               p.x += p.vx;
               p.y += p.vy;
               p.angle += p.spin;
               p.opacity -= 0.007; // Fade out

               if (p.opacity <= 0) {
                   confettiParticles.splice(i, 1);
                   return;
               }

               confettiCtx.save();
               confettiCtx.globalAlpha = p.opacity;
               confettiCtx.translate(p.x, p.y);
               confettiCtx.rotate(p.angle);
               confettiCtx.fillStyle = p.color;
               
               if (p.isCircle) {
                   confettiCtx.beginPath();
                   confettiCtx.arc(0, 0, p.size / 2, 0, Math.PI * 2);
                   confettiCtx.fill();
               } else {
                   confettiCtx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
               }
               
               confettiCtx.restore();
           });
       }

       function animateConfetti() {
           if (confettiParticles.length > 0) {
               drawConfetti();
               animationFrameId = requestAnimationFrame(animateConfetti);
           } else {
               if(confettiCtx) confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
               cancelAnimationFrame(animationFrameId);
           }
       }

       function startConfetti(origin) {
           resizeCanvas();
           confettiParticles = [];
           createConfetti(origin);
           if (animationFrameId) cancelAnimationFrame(animationFrameId);
           animateConfetti();
       }

       // --- App State ---
       let AppState = {
           currentUser: { uid: null, username: null, userTag: null, stats: { wins: 0, losses: 0 }, friends: {} },
           currentRoom: { id: null, data: null, countdownInterval: null },
           playerSymbol: '',
           listeners: { room: null, user: null },
           game: { state: Array(9).fill(""), history: [], currentPlayer: "X", isActive: false, mode: 'bot' },
           loadingTimeout: null,
       };

       // --- DOM Elements ---
       const DOM = {
           screens: {
               mainMenu: document.getElementById('main-menu'),
               settings: document.getElementById('settings-screen'),
               coopMenu: document.getElementById('coop-menu'),
               roomLobby: document.getElementById('room-lobby'),
               game: document.getElementById('game-screen'),
           },
           modals: {
               profile: document.getElementById('profile-modal'),
           },
           contextMenu: document.getElementById('context-menu'),
           gameBoard: document.getElementById('game-board'),
           winningLineContainer: document.getElementById('winning-line-container'),
           turnDisplay: document.getElementById('turn-display'),
       };

       // --- Utility Functions ---
       const showToast = (message, type = 'info') => {
           const toast = document.getElementById('toast-notification');
           const toastMessage = document.getElementById('toast-message');
           toastMessage.textContent = message;
           toast.className = `fixed top-5 right-5 text-white px-6 py-3 rounded-lg shadow-lg transition-all duration-300 z-50 opacity-100 transform translate-y-0 ${type === 'error' ? 'bg-red-600' : 'bg-gray-800'}`;
           setTimeout(() => {
               toast.classList.replace('opacity-100', 'opacity-0');
               toast.classList.replace('translate-y-0', '-translate-y-10');
           }, 3000);
       };
       
       const showErrorScreen = (show = true) => {
           const errorOverlay = document.getElementById('connection-error-overlay');
           if (show) {
               document.getElementById('loading-overlay').style.display = 'none';
               errorOverlay.style.display = 'flex';
           } else {
               errorOverlay.style.display = 'none';
           }
       };

       const showScreen = (screenName) => {
           Object.values(DOM.screens).forEach(s => s.classList.remove('active'));
           if(DOM.screens[screenName]) DOM.screens[screenName].classList.add('active');
       };

       const showModal = (modalName, show = true) => {
           if(DOM.modals[modalName]) DOM.modals[modalName].classList.toggle('active', show);
       };

       const generateRandomName = () => {
           const randomNumber = Math.floor(1000 + Math.random() * 9000);
           return `Player${randomNumber}`;
       };
       
       // --- Initialization ---
       const init = () => {
           addEventListeners();
           
           AppState.loadingTimeout = setTimeout(() => {
               console.error("Connection timed out.");
               showErrorScreen(true);
           }, CONST.CONNECTION_TIMEOUT);

           onAuthStateChanged(auth, async (user) => {
               try {
                   if (!user) {
                       await signInAnonymously(auth);
                       // The listener will re-trigger with the new user, so we just wait.
                       return;
                   }
                   AppState.currentUser.uid = user.uid;
                   await checkUserRegistration();
                   
                   // Success, clear timeout
                   clearTimeout(AppState.loadingTimeout);

               } catch (e) {
                   console.error("Error during authentication or user setup:", e);
                   clearTimeout(AppState.loadingTimeout);
                   showErrorScreen(true);
               }
           });
       };
       
       // --- User & Profile Management ---
       const checkUserRegistration = async () => {
           const loadingOverlay = document.getElementById('loading-overlay');
           const userRef = doc(db, "users", AppState.currentUser.uid);
           const userSnap = await getDoc(userRef);

           if (userSnap.exists()) {
               const userData = userSnap.data();
               AppState.currentUser = { ...AppState.currentUser, ...userData };
               document.getElementById('welcome-message').innerText = `ยินดีต้อนรับ, ${AppState.currentUser.username}#${AppState.currentUser.userTag}`;
               
               showScreen('mainMenu');
               listenToUserUpdates();
           } else {
               const newUsername = generateRandomName();
               const userTag = AppState.currentUser.uid.substring(0, CONST.USER_TAG_LENGTH);
               const newUserData = {
                   username: newUsername,
                   userTag: userTag,
                   stats: { wins: 0, losses: 0 },
                   friends: {},
                   createdAt: serverTimestamp()
               };

               await setDoc(userRef, newUserData);

               AppState.currentUser = { ...AppState.currentUser, ...newUserData };
               document.getElementById('welcome-message').innerText = `ยินดีต้อนรับ, ${newUsername}#${userTag}`;
               
               showScreen('mainMenu');
               listenToUserUpdates();
           }
           
           loadingOverlay.style.opacity = '0';
           setTimeout(() => { loadingOverlay.style.display = 'none'; }, 300);
       };
     
       const listenToUserUpdates = () => {
           if(AppState.listeners.user) AppState.listeners.user();
           const userRef = doc(db, "users", AppState.currentUser.uid);
           AppState.listeners.user = onSnapshot(userRef, (docSnap) => {
               if (docSnap.exists()) {
                   const userData = docSnap.data();
                   AppState.currentUser = { ...AppState.currentUser, ...userData };
                   updateFriendsUI();
               }
           });
       }

       async function handleSaveUsername() {
           const input = document.getElementById('change-username-input');
           const errorP = document.getElementById('change-username-error');
           const newUsername = input.value.trim();
           const usernameRegex = /^[a-zA-Z0-9]+$/;

           errorP.textContent = '';
           if (newUsername.length < 3 || newUsername.length > 12) {
               errorP.textContent = 'ชื่อต้องมี 3-12 ตัวอักษร';
               return;
           }
           if (!usernameRegex.test(newUsername)) {
               errorP.textContent = 'ต้องเป็นภาษาอังกฤษหรือตัวเลขเท่านั้น';
               return;
           }
           if (newUsername === AppState.currentUser.username) {
               showToast('ชื่อผู้ใช้เหมือนเดิม');
               showScreen('mainMenu');
               return;
           }

           const userRef = doc(db, "users", AppState.currentUser.uid);
           try {
               await updateDoc(userRef, { username: newUsername });
               showToast('เปลี่ยนชื่อสำเร็จ!');
               document.getElementById('welcome-message').innerText = `ยินดีต้อนรับ, ${newUsername}#${AppState.currentUser.userTag}`;
               showScreen('mainMenu');
           } catch (error) {
               console.error("Error saving username: ", error);
               showToast("เกิดข้อผิดพลาดในการบันทึกชื่อ", 'error');
               errorP.textContent = 'เกิดข้อผิดพลาด กรุณาลองใหม่';
           }
       }

       // --- Friend Management ---
       async function handleSearchUsers() {
           const searchTerm = document.getElementById('search-user-input').value.trim();
           const resultsDiv = document.getElementById('search-results');
           resultsDiv.innerHTML = 'กำลังค้นหา...';

           if (searchTerm.length < 1) {
               resultsDiv.innerHTML = '<p class="text-gray-500">กรุณาพิมพ์ชื่อที่ต้องการค้นหา</p>';
               return;
           }

           const q = query(collection(db, "users"), where("username", "==", searchTerm));
           const querySnapshot = await getDocs(q);

           if (querySnapshot.empty) {
               resultsDiv.innerHTML = '<p class="text-gray-500">ไม่พบผู้เล่น</p>';
           } else {
               resultsDiv.innerHTML = '';
               querySnapshot.forEach(docSnap => {
                   const user = docSnap.data();
                   const uid = docSnap.id;
                   if (uid === AppState.currentUser.uid) return;

                   const userDiv = document.createElement('div');
                   userDiv.className = 'flex justify-between items-center p-2 bg-gray-100 rounded-md mb-1';
                   
                   const friendStatus = AppState.currentUser.friends[uid];
                   let buttonHtml = '';
                   if (friendStatus === 'accepted') {
                       buttonHtml = '<span class="text-green-500">เป็นเพื่อนกันแล้ว</span>';
                   } else if (friendStatus === 'pending_sent') {
                       buttonHtml = '<span class="text-gray-500">ส่งคำขอแล้ว</span>';
                   } else if (friendStatus === 'pending_received') {
                       buttonHtml = `<button data-uid="${uid}" class="accept-friend-btn button button-success !py-1 !px-3 !my-0 !text-sm">รับ</button>`;
                   } else {
                       buttonHtml = `<button data-uid="${uid}" class="add-friend-btn button button-primary !py-1 !px-3 !my-0 !text-sm">เพิ่มเพื่อน</button>`;
                   }

                   userDiv.innerHTML = `<span>${user.username}#${user.userTag}</span> ${buttonHtml}`;
                   resultsDiv.appendChild(userDiv);
               });
           }
       }

       async function sendFriendRequest(targetUid) {
           const batch = writeBatch(db);
           batch.update(doc(db, "users", AppState.currentUser.uid), { [`friends.${targetUid}`]: 'pending_sent' });
           batch.update(doc(db, "users", targetUid), { [`friends.${AppState.currentUser.uid}`]: 'pending_received' });
           await batch.commit();
           showToast('ส่งคำขอเป็นเพื่อนแล้ว!');
           handleSearchUsers();
       }

       async function acceptFriendRequest(targetUid) {
           const batch = writeBatch(db);
           batch.update(doc(db, "users", AppState.currentUser.uid), { [`friends.${targetUid}`]: 'accepted' });
           batch.update(doc(db, "users", targetUid), { [`friends.${AppState.currentUser.uid}`]: 'accepted' });
           await batch.commit();
           showToast('รับเป็นเพื่อนแล้ว!');
       }

       async function updateFriendsUI() {
           const requestsList = document.getElementById('friend-requests-list');
           const friendsList = document.getElementById('friends-list');
           
           const friendUIDs = Object.keys(AppState.currentUser.friends);
           if (friendUIDs.length === 0) {
               requestsList.innerHTML = '<p class="text-gray-500">ไม่มีคำขอ</p>';
               friendsList.innerHTML = '<p class="text-gray-500">ยังไม่มีเพื่อน</p>';
               return;
           }

           const friendPromises = friendUIDs.map(uid => getDoc(doc(db, "users", uid)));
           const friendDocs = await Promise.all(friendPromises);

           let requestsHTML = '';
           let friendsHTML = '';

           friendDocs.forEach(docSnap => {
               if (!docSnap.exists()) return;
               const user = docSnap.data();
               const uid = docSnap.id;
               const status = AppState.currentUser.friends[uid];
               const displayName = `${user.username}#${user.userTag}`;

               if (status === 'pending_received') {
                   requestsHTML += `<div class="flex justify-between items-center p-2"><span>${displayName}</span><button data-uid="${uid}" class="accept-friend-btn button button-success !py-1 !px-3 !my-0 !text-sm">รับ</button></div>`;
               } else if (status === 'accepted') {
                   friendsHTML += `<div class="p-2">${displayName}</div>`;
               }
           });

           requestsList.innerHTML = requestsHTML || '<p class="text-gray-500">ไม่มีคำขอ</p>';
           friendsList.innerHTML = friendsHTML || '<p class="text-gray-500">ยังไม่มีเพื่อน</p>';
       }
       
       async function viewProfile(uid) {
           const userSnap = await getDoc(doc(db, 'users', uid));
           if (userSnap.exists()) {
               const user = userSnap.data();
               document.getElementById('profile-username').textContent = `${user.username}#${user.userTag}`;
               document.getElementById('profile-wins').textContent = user.stats?.wins || 0;
               document.getElementById('profile-losses').textContent = user.stats?.losses || 0;
               showModal('profile', true);
           }
       }
       
       // --- Game Logic ---
       function startGame() {
           document.getElementById('game-screen-over-overlay').classList.add('hidden');
           document.getElementById('game-screen-over-overlay').classList.remove('flex');
           document.getElementById('leave-game-btn').style.display = 'flex';

           AppState.game.state.fill("");
           AppState.game.history = [];
           AppState.game.isActive = true;
           
           if (AppState.game.mode === 'bot') {
               const playerStarts = Math.random() < 0.5;
               AppState.game.currentPlayer = playerStarts ? 'X' : 'O'; // Player is X, Bot is O
           } else {
               AppState.game.currentPlayer = "X"; // Coop always starts with X
           }

           DOM.winningLineContainer.innerHTML = '';
           DOM.gameBoard.innerHTML = '';
           for (let i = 0; i < 9; i++) {
               const cell = document.createElement('div');
               cell.classList.add('cell');
               cell.dataset.index = i;
               cell.onclick = handleCellClick;
               DOM.gameBoard.appendChild(cell);
           }
           showScreen('game');
           updateTurnDisplay();
           if (AppState.game.mode === 'bot' && AppState.game.currentPlayer === 'O') setTimeout(botMove, 500);
       }

       function handleCellClick(event) {
           playPopSound();
           if (!AppState.game.isActive) return;
           const index = parseInt(event.target.dataset.index);

           if (AppState.game.mode === 'bot') {
               if (AppState.game.state[index] !== "" || AppState.game.currentPlayer !== 'X') return;
               makeMove(index);
               if (AppState.game.isActive) setTimeout(botMove, 500);
           } else if (AppState.game.mode === 'coop') {
               if (AppState.game.currentPlayer !== AppState.playerSymbol || AppState.game.state[index] !== "") return;
               
               // New reliable way to make a move in co-op
               const roomRef = doc(db, "rooms", AppState.currentRoom.id);
               runTransaction(db, async (transaction) => {
                   const roomDoc = await transaction.get(roomRef);
                   if (!roomDoc.exists()) throw "Room does not exist!";
                   
                   const roomData = roomDoc.data();
                   let newBoard = [...roomData.game.board];
                   let newHistory = [...(roomData.game.history || [])];

                   // Double-check move validity inside the transaction
                   if (newBoard[index] !== "" || roomData.game.turn !== AppState.playerSymbol) {
                       return; // Invalid move, do nothing
                   }
                   
                   if (newHistory.length >= CONST.MAX_MOVE_HISTORY) {
                       const oldestMove = newHistory.shift();
                       newBoard[oldestMove.index] = "";
                   }
                   
                   newBoard[index] = AppState.game.currentPlayer;
                   newHistory.push({ player: AppState.game.currentPlayer, index: index });
                   
                   const nextTurn = AppState.game.currentPlayer === 'X' ? 'O' : 'X';
                   const winnerResult = checkWinner(newBoard);

                   transaction.update(roomRef, {
                       "game.board": newBoard,
                       "game.history": newHistory,
                       "game.turn": nextTurn,
                       "game.winner": winnerResult ? winnerResult.winner : null,
                       "status": winnerResult ? 'finished' : 'playing'
                   });

                    if(winnerResult) {
                       const winnerUID = Object.keys(roomData.players).find(uid => roomData.players[uid].symbol === winnerResult.winner);
                       const loserUID = Object.keys(roomData.players).find(uid => roomData.players[uid].symbol !== winnerResult.winner);
                       if (winnerUID && loserUID) {
                           updatePlayerStats(winnerUID, loserUID);
                       }
                   }
               }).catch(error => {
                   console.error("Transaction failed: ", error);
                   showToast("เกิดข้อผิดพลาดในการเดิน", 'error');
               });
           }
       }
       
       function makeMove(index) { // This function is now ONLY for bot mode
           if (AppState.game.state[index] !== "" || !AppState.game.isActive) return;
           
           if (AppState.game.history.length >= CONST.MAX_MOVE_HISTORY) {
               const oldestMove = AppState.game.history.shift();
               AppState.game.state[oldestMove.index] = "";
               const cellToClear = document.querySelector(`.cell[data-index='${oldestMove.index}']`);
               if (cellToClear) {
                   cellToClear.classList.add('fading');
                   setTimeout(() => {
                       if(cellToClear) {
                           cellToClear.innerText = "";
                           cellToClear.className = 'cell';
                       }
                   }, 500);
               }
           }
           
           AppState.game.state[index] = AppState.game.currentPlayer;
           AppState.game.history.push({ player: AppState.game.currentPlayer, index: index });
           updateBoardUI();
           
           const result = checkWinner(AppState.game.state);
           if (result) {
               endGame(false, result.winner, result);
           } else if (AppState.game.history.length === 9) {
                endGame(true);
           } else {
               AppState.game.currentPlayer = AppState.game.currentPlayer === 'X' ? 'O' : 'X';
               updateTurnDisplay();
           }
       }

       function updateBoardUI() {
           // Remove previous fade indicators
           document.querySelectorAll('.cell.indicate-fade').forEach(c => c.classList.remove('indicate-fade'));

           AppState.game.state.forEach((value, i) => {
               const cell = document.querySelector(`.cell[data-index='${i}']`);
               if (cell && cell.innerText !== value) {
                   cell.innerText = value;
                   cell.className = 'cell ' + (value ? value.toLowerCase() : '');
               } else if (cell && !value && cell.innerText) {
                    cell.innerText = '';
                    cell.className = 'cell';
               }
           });

           // Add new fade indicator
           if(AppState.game.history.length >= CONST.MAX_MOVE_HISTORY) {
               const nextToFadeIndex = AppState.game.history[0].index;
               const cellToIndicate = document.querySelector(`.cell[data-index='${nextToFadeIndex}']`);
               if (cellToIndicate) cellToIndicate.classList.add('indicate-fade');
           }
       }
       
       function updateTurnDisplay() {
           if (!AppState.game.isActive) {
               DOM.turnDisplay.innerText = '';
               return;
           }
           if (AppState.game.mode === 'coop') {
               DOM.turnDisplay.innerText = (AppState.game.currentPlayer === AppState.playerSymbol) ? "ตาของคุณ!" : `รอตาของฝ่ายตรงข้าม (${AppState.game.currentPlayer})`;
           } else {
               DOM.turnDisplay.innerText = AppState.game.currentPlayer === 'X' ? `ตาของคุณ (X)` : `ตาของบอท (O)`;
           }
       }

       function checkWinner(board) {
           const lines = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
           for (const line of lines) {
               const [a, b, c] = line;
               if (board[a] && board[a] === board[b] && board[a] === board[c]) return { winner: board[a], line: line };
           }
           return null;
       }

       function drawWinningLine(result) {
           const lineDiv = document.createElement('div');
           lineDiv.className = 'winning-line';
           
           const line = result.line;
           const boardSize = DOM.gameBoard.offsetWidth;
           const cellSize = boardSize / 3;
           let angle = 0; let top = 0; let left = 0; let width = boardSize;
           const lineHeightOffset = 6; // Half of the line's height (12px)

           // Horizontal
           if (line[0] === 0 && line[2] === 2) { top = (cellSize * 0.5) - lineHeightOffset; left = 0; angle = 0; }
           else if (line[0] === 3 && line[2] === 5) { top = (cellSize * 1.5) - lineHeightOffset; left = 0; angle = 0; }
           else if (line[0] === 6 && line[2] === 8) { top = (cellSize * 2.5) - lineHeightOffset; left = 0; angle = 0; }
           // Vertical
           else if (line[0] === 0 && line[2] === 6) { top = (boardSize / 2) - (boardSize / 2); left = (cellSize * 0.5) - lineHeightOffset + (boardSize / 2) ; angle = 90; }
           else if (line[0] === 1 && line[2] === 7) { top = (boardSize / 2) - (boardSize / 2); left = (cellSize * 1.5) - lineHeightOffset + (boardSize / 2); angle = 90; }
           else if (line[0] === 2 && line[2] === 8) { top = (boardSize / 2) - (boardSize / 2); left = (cellSize * 2.5) - lineHeightOffset + (boardSize / 2); angle = 90; }
           // Diagonal
           else if (line[0] === 0 && line[2] === 8) { top = 0; left = 0; angle = 45; width = boardSize * 1.414; lineDiv.style.transformOrigin = 'top left'; }
           else if (line[0] === 2 && line[2] === 6) { top = boardSize; left = 0; angle = -45; width = boardSize * 1.414; lineDiv.style.transformOrigin = 'bottom left'; }

           lineDiv.style.setProperty('--line-width', `${width}px`);
           lineDiv.style.transform = `translate(${left}px, ${top}px) rotate(${angle}deg)`;
           DOM.winningLineContainer.appendChild(lineDiv);
       }

       function endGame(isDraw, winner = null, result = null) {
           AppState.game.isActive = false;
           document.getElementById('leave-game-btn').style.display = 'none';
           
           const overlay = document.getElementById('game-screen-over-overlay');
           const message = document.getElementById('game-over-message');

           if (isDraw) {
               message.innerText = "เสมอ!";
           } else {
               message.innerText = `ผู้เล่น ${winner} ชนะ!`;
               if(result) drawWinningLine(result);
           }
           
           setTimeout(() => { // Delay overlay to see winning line
               overlay.classList.remove('hidden');
               overlay.classList.add('flex');

               if (!isDraw) {
                   const boardRect = DOM.gameBoard.getBoundingClientRect();
                   const origin = {
                       x: boardRect.left + boardRect.width / 2,
                       y: boardRect.top + boardRect.height / 2,
                   };
                   startConfetti(origin);
               }
           }, 700);
       }

       // --- Bot Logic ---
       function botMove() {
           if (!AppState.game.isActive) return;
           makeMove(getBestBotMove());
       }
       
       function getBestBotMove() {
           const board = AppState.game.state;

           // 1. Win: If bot can win, it takes the winning move.
           for (let i = 0; i < 9; i++) { if (board[i] === "") { let b = [...board]; b[i] = 'O'; if (checkWinner(b)) return i; } }
           
           // 2. Block: If player is about to win, block them.
           for (let i = 0; i < 9; i++) { if (board[i] === "") { let b = [...board]; b[i] = 'X'; if (checkWinner(b)) return i; } }

           // 3. Anti-Fork Strategy: If player takes opposite corners and bot has the center, play a side to block a fork.
           if (board[4] === 'O') {
               if ((board[0] === 'X' && board[8] === 'X') || (board[2] === 'X' && board[6] === 'X')) {
                   const sides = [1, 3, 5, 7].filter(i => board[i] === '');
                   if (sides.length > 0) return sides[Math.floor(Math.random() * sides.length)];
               }
           }

           // 4. Center: Take the center if it's available.
           if (board[4] === "") return 4;

           // 5. Opposite Corner: If the opponent is in a corner, take the opposite one.
           const cornerMap = { 0: 8, 2: 6, 6: 2, 8: 0 };
           for(const c in cornerMap) {
               if(board[c] === 'X' && board[cornerMap[parseInt(c)]] === '') {
                   return cornerMap[parseInt(c)];
               }
           }
           
           // 6. Empty Corner: Take any available corner.
           const corners = [0, 2, 6, 8].filter(i => board[i] === '');
           if (corners.length > 0) return corners[Math.floor(Math.random() * corners.length)];

           // 7. Empty Side: Take any available side.
           const sides = [1, 3, 5, 7].filter(i => board[i] === '');
           if (sides.length > 0) return sides[Math.floor(Math.random() * sides.length)];

           return board.findIndex(s => s === ""); // Failsafe
       }

       // --- Online (Co-op) Logic ---
       async function handleCreateRoom(button) {
           button.disabled = true;
           button.innerHTML = '<span>กำลังสร้าง...</span>';
           
           const roomId = Math.random().toString(36).substring(2, 2 + CONST.ROOM_CODE_LENGTH).toUpperCase();
           const creatorSymbol = Math.random() < 0.5 ? 'X' : 'O'; // Randomize symbol
           AppState.currentRoom.id = roomId;
           AppState.playerSymbol = creatorSymbol; // Set for creator
           const roomData = {
               status: 'lobby',
               players: {
                   [AppState.currentUser.uid]: { username: AppState.currentUser.username, userTag: AppState.currentUser.userTag, symbol: creatorSymbol, ready: false }
               },
               game: { board: Array(9).fill(""), history: [], turn: "X", winner: null, lastMove: null },
               createdAt: serverTimestamp()
           };
           try {
               await setDoc(doc(db, "rooms", roomId), roomData);
               listenToRoomUpdates(roomId);
               showScreen('roomLobby');
           } catch (error) {
               console.error("Error creating room:", error);
               showToast("สร้างห้องไม่สำเร็จ", 'error');
           } finally {
               button.disabled = false;
               button.innerHTML = '<span>สร้างห้อง</span>';
           }
       }

       async function handleJoinRoom() {
           const roomId = document.getElementById('room-code-input').value.trim().toUpperCase();
           if (!roomId) return showToast("กรุณาใส่รหัสห้อง", 'error');
           
           const roomRef = doc(db, "rooms", roomId);
           const roomSnap = await getDoc(roomRef);

           if (roomSnap.exists()) {
               const roomData = roomSnap.data();
               if (Object.keys(roomData.players).length >= 2) return showToast("ห้องเต็มแล้ว", 'error');
               if (roomData.status !== 'lobby') return showToast("เกมเริ่มไปแล้ว", 'error');
               
               const existingPlayerSymbol = Object.values(roomData.players)[0].symbol;
               const joinerSymbol = existingPlayerSymbol === 'X' ? 'O' : 'X';

               AppState.currentRoom.id = roomId;
               AppState.playerSymbol = joinerSymbol; // Set for joiner
               await updateDoc(roomRef, {
                   [`players.${AppState.currentUser.uid}`]: { username: AppState.currentUser.username, userTag: AppState.currentUser.userTag, symbol: joinerSymbol, ready: false }
               });
               listenToRoomUpdates(roomId);
               showScreen('roomLobby');
           } else {
               showToast("ไม่พบห้องนี้", 'error');
           }
       }

       function listenToRoomUpdates(roomId) {
           if (AppState.listeners.room) AppState.listeners.room();
           const roomRef = doc(db, "rooms", roomId);
           AppState.listeners.room = onSnapshot(roomRef, (docSnap) => {
               if (!docSnap.exists()) {
                   const activeScreenId = document.querySelector('.screen.active')?.id;
                   if (activeScreenId === 'room-lobby' || activeScreenId === 'game-screen') {
                       showToast("ห้องถูกปิดแล้ว", 'info');
                       cleanupAfterRoom();
                   } else {
                       if (AppState.listeners.room) AppState.listeners.room();
                       AppState.listeners.room = null;
                       AppState.currentRoom = { id: null, data: null };
                       AppState.playerSymbol = '';
                   }
                   return;
               }
               const roomData = docSnap.data();
               const oldData = AppState.currentRoom.data;
               AppState.currentRoom.data = roomData;
               
               updateLobbyUI(roomData);

               if (roomData.status === 'playing' && (!oldData || oldData.status !== 'playing')) {
                   AppState.game.mode = 'coop';
                   document.getElementById('restart-game-btn').style.display = (Object.keys(roomData.players)[0] === AppState.currentUser.uid) ? 'flex' : 'none';
                   startGame();
               }
               if (roomData.status === 'lobby' && DOM.screens.roomLobby.style.display === 'none') {
                   showScreen('roomLobby');
               }

               if (roomData.game) {
                   // The game state is now directly driven by Firestore, no more client-side move making for co-op
                   if (JSON.stringify(AppState.game.state) !== JSON.stringify(roomData.game.board || [])) {
                       AppState.game.state = roomData.game.board || Array(9).fill("");
                       AppState.game.history = roomData.game.history || [];
                       updateBoardUI();
                   }
                   
                   AppState.game.currentPlayer = roomData.game.turn;
                   updateTurnDisplay();
                   
                   if (roomData.status === 'finished' && roomData.game.winner && AppState.game.isActive) {
                        AppState.game.isActive = false; // Prevent multiple endGame calls
                       const result = checkWinner(roomData.game.board);
                       endGame(false, roomData.game.winner, result);
                   }
               }
           }, (error) => {
               console.error("Room listener error:", error);
               showToast("การเชื่อมต่อห้องมีปัญหา", "error");
               cleanupAfterRoom();
           });
       }
     
       function updateLobbyUI(data) {
          document.getElementById('room-code-display').innerText = AppState.currentRoom.id;
          const playerListDiv = document.getElementById('player-list');
          playerListDiv.innerHTML = '';
          const lobbyStatus = document.getElementById('lobby-status');
          const readyBtn = document.getElementById('ready-btn');

          let allReady = Object.keys(data.players).length === 2;
          Object.entries(data.players).forEach(([uid, p]) => {
              const displayName = `${p.username}#${p.userTag}`;
              const playerDiv = document.createElement('div');
              playerDiv.dataset.uid = uid;
              playerDiv.className = 'player-name-lobby cursor-pointer hover:bg-gray-100 p-1 rounded';
              const statusText = p.ready
                  ? '<span class="text-green-500 font-semibold">พร้อม</span>'
                  : '<span class="text-red-500">ยังไม่พร้อม</span>';
              playerDiv.innerHTML = `<span>${displayName} (${p.symbol}) - ${statusText}</span>`;
              playerListDiv.appendChild(playerDiv);
              if (!p.ready) allReady = false;
          });
         
          if (!allReady && AppState.currentRoom.countdownInterval) {
               clearInterval(AppState.currentRoom.countdownInterval);
               AppState.currentRoom.countdownInterval = null;
               lobbyStatus.textContent = "รอผู้เล่นกดพร้อม";
               readyBtn.style.display = 'flex';
          }

          if (allReady && !AppState.currentRoom.countdownInterval) {
               readyBtn.style.display = 'none';
               startLobbyCountdown();
          } else if (!allReady) {
               lobbyStatus.textContent = Object.keys(data.players).length === 2 ? "รอผู้เล่นกดพร้อม" : "รอผู้เล่นอีกคน...";
          }
      }

      function startLobbyCountdown() {
           let countdown = 5;
           const lobbyStatus = document.getElementById('lobby-status');
           lobbyStatus.innerHTML = `เกมจะเริ่มใน <span class="font-bold text-xl">${countdown}</span>`;

           AppState.currentRoom.countdownInterval = setInterval(() => {
               countdown--;
               if (countdown > 0) {
                   lobbyStatus.innerHTML = `เกมจะเริ่มใน <span class="font-bold text-xl">${countdown}</span>`;
               } else {
                   clearInterval(AppState.currentRoom.countdownInterval);
                   AppState.currentRoom.countdownInterval = null;
                   lobbyStatus.textContent = "กำลังเริ่มเกม...";
                   if (Object.keys(AppState.currentRoom.data.players)[0] === AppState.currentUser.uid) {
                       const roomRef = doc(db, "rooms", AppState.currentRoom.id);
                       runTransaction(db, async (t) => {
                           const roomDoc = await t.get(roomRef);
                           if(!roomDoc.exists()) return;
                           const initialBoard = Array(9).fill("");
                           t.update(roomRef, {
                               status: 'playing',
                               'game.board': initialBoard,
                               'game.history': [],
                               'game.turn': 'X',
                               'game.winner': null,
                           });
                       });
                   }
               }
           }, 1000);
      }
     
       async function handleReadyClick() {
           if (!AppState.currentRoom.id || !AppState.currentRoom.data || AppState.currentRoom.countdownInterval) return;
           const currentReadyStatus = AppState.currentRoom.data.players[AppState.currentUser.uid]?.ready || false;
           await updateDoc(doc(db, "rooms", AppState.currentRoom.id), { [`players.${AppState.currentUser.uid}.ready`]: !currentReadyStatus });
       }

       async function handleLeaveRoom(button) {
           if (!AppState.currentRoom.id) return;

           if(button) button.disabled = true;

           const roomId = AppState.currentRoom.id;
           
           if (AppState.listeners.room) AppState.listeners.room();
           AppState.listeners.room = null;

           const roomRef = doc(db, "rooms", roomId);
           try {
               await runTransaction(db, async (transaction) => {
                   const roomDoc = await transaction.get(roomRef);
                   if (!roomDoc.exists()) return;

                   const roomData = roomDoc.data();
                   const players = roomData.players;
                   const wasInGame = roomData.status === 'playing';
                   delete players[AppState.currentUser.uid];

                   if (Object.keys(players).length > 0) {
                       let updates = { players };
                       if (wasInGame) {
                           const remainingPlayerUID = Object.keys(players)[0];
                           const winnerUID = remainingPlayerUID;
                           const loserUID = AppState.currentUser.uid;
                           await updatePlayerStats(winnerUID, loserUID); // Update stats for leaver
                           updates['game.winner'] = players[remainingPlayerUID].symbol;
                           updates['status'] = 'finished';
                       }
                       transaction.update(roomRef, updates);
                   } else {
                       transaction.delete(roomRef);
                   }
               });
           } catch (error) {
               console.error("Error leaving room:", error);
           } finally {
               cleanupAfterRoom();
           }
       }

       function cleanupAfterRoom() {
           if (AppState.currentRoom.countdownInterval) {
               clearInterval(AppState.currentRoom.countdownInterval);
           }
           AppState.currentRoom = { id: null, data: null, countdownInterval: null };
           AppState.playerSymbol = '';
           showScreen('mainMenu');

           // Explicitly show the ready button again for new rooms
           const readyBtn = document.getElementById('ready-btn');
           if(readyBtn) readyBtn.style.display = 'flex';

           const leaveRoomBtn = document.getElementById('leave-room-btn');
           if(leaveRoomBtn) leaveRoomBtn.disabled = false;
           const leaveGameBtn = document.getElementById('leave-game-btn');
           if(leaveGameBtn) leaveGameBtn.disabled = false;
           const backToMenuBtn = document.getElementById('back-to-menu-from-game-btn');
           if(backToMenuBtn) backToMenuBtn.disabled = false;
       }

       async function updatePlayerStats(winnerUID, loserUID) {
           if (!winnerUID || !loserUID) return;
           const winnerRef = doc(db, "users", winnerUID);
           const loserRef = doc(db, "users", loserUID);
           
           await runTransaction(db, async (t) => {
               const winnerDoc = await t.get(winnerRef);
               const loserDoc = await t.get(loserRef);
               if(!winnerDoc.exists() || !loserDoc.exists()) throw "User document is missing";
               
               const newWins = (winnerDoc.data().stats.wins || 0) + 1;
               const newLosses = (loserDoc.data().stats.losses || 0) + 1;
               
               t.update(winnerRef, { "stats.wins": newWins });
               t.update(loserRef, { "stats.losses": newLosses });
           });
       }
     
       // --- Event Listeners Setup ---
       function addEventListeners() {
           document.getElementById('play-bot-btn').onclick = () => { AppState.game.mode = 'bot'; startGame(); };
           document.getElementById('play-coop-btn').onclick = () => showScreen('coopMenu');
           document.getElementById('settings-btn').onclick = () => {
               document.getElementById('change-username-input').value = AppState.currentUser.username;
               updateFriendsUI();
               showScreen('settings');
           };
           document.getElementById('back-to-main-from-settings-btn').onclick = () => showScreen('mainMenu');
           document.getElementById('back-to-main-from-coop-btn').onclick = () => showScreen('mainMenu');
           document.getElementById('save-settings-btn').onclick = handleSaveUsername;
           document.getElementById('search-user-btn').onclick = handleSearchUsers;
           document.getElementById('search-results').addEventListener('click', e => {
               if (e.target.closest('.add-friend-btn')) sendFriendRequest(e.target.closest('.add-friend-btn').dataset.uid);
               if (e.target.closest('.accept-friend-btn')) acceptFriendRequest(e.target.closest('.accept-friend-btn').dataset.uid);
           });
           document.getElementById('friend-requests-list').addEventListener('click', e => {
               if (e.target.closest('.accept-friend-btn')) acceptFriendRequest(e.target.closest('.accept-friend-btn').dataset.uid);
           });
           document.getElementById('create-room-btn').onclick = (e) => handleCreateRoom(e.currentTarget);
           document.getElementById('join-room-btn').onclick = handleJoinRoom;
           document.getElementById('ready-btn').onclick = handleReadyClick;
           document.getElementById('leave-room-btn').onclick = (e) => handleLeaveRoom(e.currentTarget);
           document.getElementById('copy-room-code-btn').onclick = () => {
               if (AppState.currentRoom.id) {
                   navigator.clipboard.writeText(AppState.currentRoom.id);
                   showToast('คัดลอกรหัสห้องแล้ว!');
               }
           };
           document.getElementById('leave-game-btn').onclick = (e) => {
               if (AppState.game.mode === 'coop') handleLeaveRoom(e.currentTarget);
               else showScreen('mainMenu');
           };
           
           document.getElementById('restart-game-btn').onclick = () => {
               if (AppState.game.mode === 'bot') {
                   startGame();
               } else if (AppState.game.mode === 'coop') {
                   const roomRef = doc(db, "rooms", AppState.currentRoom.id);
                   const players = AppState.currentRoom.data.players;
                   Object.keys(players).forEach(uid => { players[uid].ready = false; });
                   
                   updateDoc(roomRef, {
                       players: players,
                       status: "lobby"
                   });
               }
           };

           document.getElementById('back-to-menu-from-game-btn').onclick = (e) => {
                if (AppState.game.mode === 'coop' && AppState.currentRoom.id) handleLeaveRoom(e.currentTarget);
                else showScreen('mainMenu');
           };

           document.getElementById('close-profile-btn').onclick = () => showModal('profile', false);
           document.getElementById('player-list').addEventListener('click', (e) => {
               const playerDiv = e.target.closest('.player-name-lobby');
               if (playerDiv) {
                   e.stopPropagation();
                   const targetUid = playerDiv.dataset.uid;
                   const rect = playerDiv.getBoundingClientRect();
                   DOM.contextMenu.style.left = `${rect.left}px`;
                   DOM.contextMenu.style.top = `${rect.bottom + 5}px`;
                   DOM.contextMenu.style.display = 'block';
                   document.getElementById('view-profile-ctx-btn').dataset.uid = targetUid;
               }
           });
           document.getElementById('view-profile-ctx-btn').onclick = (e) => {
               const targetUid = e.target.dataset.uid;
               if (targetUid) viewProfile(targetUid);
               DOM.contextMenu.style.display = 'none';
           };
           document.addEventListener('click', (e) => {
               if (!e.target.closest('.context-menu')) {
                   DOM.contextMenu.style.display = 'none';
               }
           });
       }
       
       // --- Start the App ---
       init();
   </script>
</body>
</html>