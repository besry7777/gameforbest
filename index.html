<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Super XO Game</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Kanit:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
      /* CSS for Loading Screen */
      .loader-overlay {
          position: fixed;
          inset: 0;
          background-color: rgba(255, 255, 255, 0.9);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 9999;
          transition: opacity 0.3s ease-in-out;
      }
      .loader {
          border: 8px solid #f3f3f3; /* Light grey */
          border-top: 8px solid #3b82f6; /* Blue */
          border-radius: 50%;
          width: 60px;
          height: 60px;
          animation: spin 1s linear infinite;
      }
      @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
      }

      :root {
          --x-color: #ef4444; /* red-500 */
          --o-color: #3b82f6; /* blue-500 */
      }
      body { font-family: 'Kanit', sans-serif; -webkit-tap-highlight-color: transparent; touch-action: manipulation; }
      .screen, .modal-overlay { display: none; }
      .screen.active, .modal-overlay.active { display: flex; }
      .input-field { @apply w-full px-4 py-3 mb-4 text-center bg-gray-100 border-2 border-gray-300 rounded-lg focus:outline-none focus:border-blue-500 transition-colors; }
      .button { @apply w-full max-w-sm px-4 py-3 my-2 text-lg font-semibold text-white transition-transform duration-150 ease-in-out rounded-lg shadow-md transform active:scale-95 flex justify-center items-center gap-2; }
      .button:disabled { @apply bg-gray-400 opacity-70 cursor-not-allowed transform-none; }
      .button-primary { @apply bg-gradient-to-br from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700; }
      .button-secondary { @apply bg-gradient-to-br from-gray-500 to-gray-600 hover:from-gray-600 hover:to-gray-700; }
      .button-success { @apply bg-gradient-to-br from-green-500 to-green-600 hover:from-green-600 hover:to-green-700; }
      .button-danger { @apply bg-gradient-to-br from-red-500 to-red-600 hover:from-red-600 hover:to-red-700; }
      .button-warning { @apply bg-gradient-to-br from-yellow-500 to-yellow-600 hover:from-yellow-600 hover:to-yellow-700; }
      .cell {
          position: relative;
          display: flex;
          justify-content: center;
          align-items: center;
          font-size: clamp(3rem, 18vmin, 7rem);
          font-weight: bold;
          cursor: pointer;
          border: 2px solid #e5e7eb; /* gray-200 */
          transition: background-color 0.2s;
          line-height: 1; /* Prevents text from affecting cell height */
      }
      .cell:hover { background-color: #f9fafb; /* gray-50 */ }
      .cell.x { color: var(--x-color); }
      .cell.o { color: var(--o-color); }
      .cell.fading { animation: fadeOut 0.5s forwards; }
      @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
      .cell.indicate-fade {
          animation: pulseFade 1.5s infinite;
      }
      @keyframes pulseFade { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
      #game-board {
          display: grid;
          grid-template-columns: repeat(3, 1fr);
          width: 90vw;
          height: 90vw;
          max-width: 450px;
          max-height: 450px;
          aspect-ratio: 1 / 1;
          position: relative;
      }
      .context-menu {
          position: absolute;
          display: none;
          z-index: 1000;
      }
      .winning-line {
          position: absolute;
          background-color: rgba(255, 215, 0, 0.8);
          height: 12px;
          border-radius: 6px;
          transform-origin: top left;
          animation: drawLine 0.5s ease-out forwards;
      }
      @keyframes drawLine {
          from { width: 0; }
          to { width: var(--line-width); }
      }
  </style>
</head>
<body class="bg-gray-50 text-gray-800">

  <div id="loading-overlay" class="loader-overlay">
      <div class="loader"></div>
  </div>
 
  <div id="connection-error-overlay" class="screen fixed inset-0 bg-white flex-col justify-center items-center p-5 text-center" style="z-index: 9998; display: none;">
      <h2 class="text-2xl font-bold text-red-500 mb-4">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠</h2>
      <p class="text-lg mb-6">‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå‡πÑ‡∏î‡πâ<br>‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏≠‡∏¥‡∏ô‡πÄ‡∏ó‡∏≠‡∏£‡πå‡πÄ‡∏ô‡πá‡∏ï‡πÅ‡∏•‡πâ‡∏ß‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á</p>
      <button onclick="window.location.reload()" class="button button-primary">‡πÇ‡∏´‡∏•‡∏î‡πÉ‡∏´‡∏°‡πà</button>
  </div>

  <canvas id="confetti-canvas" class="fixed top-0 left-0 w-full h-full pointer-events-none" style="z-index: 9997;"></canvas>

  <div id="toast-notification" class="fixed top-5 right-5 bg-gray-800 text-white px-6 py-3 rounded-lg shadow-lg opacity-0 transform -translate-y-10 transition-all duration-300 z-50">
      <p id="toast-message"></p>
  </div>

  <div id="context-menu" class="context-menu bg-white rounded-md shadow-lg overflow-hidden border border-gray-200">
      <button id="view-profile-ctx-btn" class="flex items-center gap-2 text-left w-full px-4 py-2 text-gray-700 hover:bg-gray-100">
          <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>
          <span>‡∏î‡∏π‡πÇ‡∏õ‡∏£‡πÑ‡∏ü‡∏•‡πå</span>
      </button>
  </div>
 
  <div id="profile-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-60 justify-center items-center p-4">
      <div class="modal-content bg-white p-6 rounded-xl shadow-2xl w-full max-w-md relative">
           <button id="close-profile-btn" class="absolute top-2 right-4 text-3xl font-bold text-gray-400 hover:text-gray-700">√ó</button>
          <h2 id="profile-username" class="text-3xl font-bold mb-4 text-center"></h2>
          <div class="text-center space-y-2">
              <div class="flex justify-center items-center gap-2 text-2xl font-semibold">
                   <span class="text-yellow-500">üí∞</span>
                   <span id="profile-coins">0</span>
              </div>
              <div>
                  <p class="font-semibold text-gray-700 text-xl">‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥ (‡∏≠‡∏≠‡∏ô‡πÑ‡∏•‡∏ô‡πå)</p>
                  <p class="text-green-500">‡∏ä‡∏ô‡∏∞: <span id="profile-wins" class="font-bold">0</span></p>
                  <p class="text-red-500">‡πÅ‡∏û‡πâ: <span id="profile-losses" class="font-bold">0</span></p>
              </div>
              <div id="profile-medals-container" class="pt-2">
                  <h3 class="font-semibold text-gray-700 text-xl">‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•</h3>
                  <div id="profile-medals-list" class="text-gray-500">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•</div>
              </div>
          </div>
      </div>
  </div>

  <main id="app-container" class="w-full h-screen overflow-hidden">
      <div id="main-menu" class="screen w-full h-full flex-col justify-center items-center p-5 text-center">
          <h1 class="text-5xl font-bold mb-2">Super XO</h1>
           <div class="flex flex-col items-center mb-6">
              <h2 id="welcome-message" class="text-2xl"></h2>
              <div class="flex items-center gap-2 text-xl mt-1 font-semibold text-yellow-600">
                  <span>üí∞</span>
                  <span id="user-coins">0</span>
              </div>
           </div>
          <button id="play-bot-btn" class="button button-primary">
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 8V4H8"></path><rect x="4" y="12" width="16" height="8" rx="2"></rect><path d="M2 14h2"></path><path d="M20 14h2"></path><path d="M15 18v-2a2 2 0 0 0-2-2h-2a2 2 0 0 0-2 2v2Z"></path></svg>
              <span>‡πÄ‡∏•‡πà‡∏ô‡∏Å‡∏±‡∏ö‡∏ö‡∏≠‡∏ó</span>
          </button>
          <button id="play-coop-btn" class="button button-success">
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>
              <span>‡πÄ‡∏•‡πà‡∏ô‡∏Å‡∏±‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô (Online)</span>
          </button>
           <button id="shop-btn" class="button button-warning">
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path><line x1="3" y1="6" x2="21" y2="6"></line><path d="M16 10a4 4 0 0 1-8 0"></path></svg>
              <span>‡∏£‡πâ‡∏≤‡∏ô‡∏Ñ‡πâ‡∏≤</span>
          </button>
          <button id="settings-btn" class="button button-secondary">
               <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
              <span>‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ & ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô</span>
          </button>
      </div>

       <!-- Shop Screen -->
      <div id="shop-screen" class="screen w-full h-full flex-col justify-start items-center p-5 overflow-y-auto">
           <div class="w-full max-w-2xl text-center">
              <h2 class="text-3xl font-bold mt-6 mb-2">‡∏£‡πâ‡∏≤‡∏ô‡∏Ñ‡πâ‡∏≤</h2>
              <div class="flex items-center justify-center gap-2 text-xl mb-6 font-semibold text-yellow-600 bg-white px-4 py-2 rounded-lg shadow-md">
                  <span>üí∞</span>
                  <span id="shop-user-coins">0</span>
              </div>
           </div>
           <div id="shop-items-grid" class="w-full max-w-2xl grid grid-cols-2 sm:grid-cols-3 gap-4">
               <!-- Shop items will be injected here -->
           </div>
           <button id="back-to-main-from-shop-btn" class="button button-secondary mx-auto mt-6">‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏°‡∏ô‡∏π‡∏´‡∏•‡∏±‡∏Å</button>
      </div>

      <div id="settings-screen" class="screen w-full h-full flex-col justify-start items-center p-5 overflow-y-auto">
          <h2 class="text-3xl font-bold my-6 text-center w-full">‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ & ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô</h2>
         
          <div class="w-full max-w-lg mx-auto bg-white p-6 rounded-lg shadow-md mb-6">
              <h3 class="text-xl font-semibold mb-2">‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ</h3>
              <input type="text" id="change-username-input" class="input-field" placeholder="‡∏≠‡∏±‡∏á‡∏Å‡∏§‡∏©/‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç, 3-12 ‡∏ï‡∏±‡∏ß" maxlength="12">
               <p id="change-username-error" class="text-red-500 mb-2 h-5 text-sm"></p>
              <button id="save-settings-btn" class="button button-primary !w-auto !px-6 !py-2 !text-base">‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡πÉ‡∏´‡∏°‡πà</button>
          </div>

          <div class="w-full max-w-lg mx-auto bg-white p-6 rounded-lg shadow-md">
              <h3 class="text-xl font-semibold mb-2">‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô</h3>
              <div class="mb-4">
                  <label for="search-user-input" class="font-semibold">‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô (‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ä‡∏∑‡πà‡∏≠):</label>
                  <div class="flex mt-1">
                      <input type="text" id="search-user-input" class="input-field !mb-0 !rounded-r-none" placeholder="‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏î‡πâ‡∏ß‡∏¢‡∏ä‡∏∑‡πà‡∏≠...">
                      <button id="search-user-btn" class="bg-blue-500 text-white px-4 rounded-r-lg hover:bg-blue-600 flex-shrink-0">‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤</button>
                  </div>
                  <div id="search-results" class="mt-2"></div>
              </div>
              <div id="friend-requests" class="mb-4">
                  <h4 class="font-semibold">‡∏Ñ‡∏≥‡∏Ç‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô:</h4>
                  <div id="friend-requests-list" class="text-gray-600">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏≥‡∏Ç‡∏≠</div>
              </div>
              <div>
                  <h4 class="font-semibold">‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô:</h4>
                  <div id="friends-list" class="text-gray-600">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô</div>
              </div>
          </div>

          <button id="back-to-main-from-settings-btn" class="button button-secondary mx-auto mt-6">‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏°‡∏ô‡∏π‡∏´‡∏•‡∏±‡∏Å</button>
      </div>

      <div id="coop-menu" class="screen w-full h-full flex-col justify-center items-center p-5">
          <h2 class="text-3xl font-bold mb-8">‡πÄ‡∏•‡πà‡∏ô‡∏Å‡∏±‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô</h2>
          <button id="create-room-btn" class="button button-primary">‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡πâ‡∏≠‡∏á</button>
          <input type="text" id="room-code-input" class="input-field max-w-sm" placeholder="‡πÉ‡∏™‡πà‡∏£‡∏´‡∏±‡∏™‡∏´‡πâ‡∏≠‡∏á" style="text-transform: uppercase;">
          <button id="join-room-btn" class="button button-success">‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°‡∏´‡πâ‡∏≠‡∏á</button>
          <button id="back-to-main-from-coop-btn" class="button button-secondary">‡∏Å‡∏•‡∏±‡∏ö</button>
      </div>

      <div id="room-lobby" class="screen w-full h-full flex-col justify-center items-center p-5 text-center">
          <h2 class="text-2xl mb-2">‡∏£‡∏´‡∏±‡∏™‡∏´‡πâ‡∏≠‡∏á:</h2>
           <div class="flex items-center justify-center gap-2 mb-6">
              <span id="room-code-display" class="text-4xl font-bold text-red-500 tracking-widest"></span>
              <button id="copy-room-code-btn" class="bg-gray-200 p-2 rounded-md hover:bg-gray-300">
                   <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
              </button>
          </div>
          <div id="player-list" class="text-xl mb-6 space-y-2 w-full max-w-sm"></div>
          <p id="lobby-status" class="mb-6 h-12 text-2xl flex justify-center items-center"></p>
          <button id="ready-btn" class="button button-success">‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏û‡∏£‡πâ‡∏≠‡∏°</button>
          <button id="leave-room-btn" class="button button-danger">‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏´‡πâ‡∏≠‡∏á</button>
      </div>
     
      <div id="game-screen" class="screen w-full h-full flex-col justify-center items-center p-2 sm:p-5">
          <div id="turn-display" class="text-2xl font-semibold mb-4 h-8"></div>
          <div id="game-board-container" class="relative">
              <div id="game-board"></div>
              <div id="winning-line-container" class="absolute top-0 left-0 w-full h-full pointer-events-none"></div>
          </div>
         
          <div id="game-screen-over-overlay" class="absolute inset-0 bg-white/80 backdrop-blur-sm flex-col justify-center items-center text-center p-5 hidden">
               <h2 id="game-over-message" class="text-4xl font-bold mb-2"></h2>
               <div id="game-rewards" class="mb-4 text-center">
                  <p id="game-coin-reward" class="text-2xl font-semibold text-yellow-600"></p>
                  <p id="game-medal-reward" class="text-lg font-semibold text-green-600"></p>
               </div>
               <div id="rematch-status" class="h-6 mb-4 text-lg"></div>
               <button id="rematch-btn" class="button button-primary">‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á</button>
               <button id="back-to-menu-from-game-btn" class="button button-secondary">‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏°‡∏ô‡∏π‡∏´‡∏•‡∏±‡∏Å</button>
          </div>

          <button id="leave-game-btn" class="button button-danger mt-6">‡∏¢‡∏≠‡∏°‡πÅ‡∏û‡πâ/‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÄ‡∏Å‡∏°</button>
      </div>
  </main>
 
  <script type="module">
      // Firebase Imports
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
      import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
      import { getFirestore, doc, getDoc, setDoc, updateDoc, collection, query, where, getDocs, onSnapshot, writeBatch, runTransaction, serverTimestamp, increment, arrayUnion } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

      // --- Firebase Config & Initialization ---
      const firebaseConfig = {
          apiKey: "AIzaSyBcxVAP08XMiPMoqElaKM7AYY_2z08oWok",
          authDomain: "xobybestry777.firebaseapp.com",
          projectId: "xobybestry777",
          storageBucket: "xobybestry777.firebasestorage.app",
          messagingSenderId: "380539937989",
          appId: "1:380539937989:web:48049ed77f45327e033cac",
          measurementId: "G-YZWTKXL285"
      };
      const app = initializeApp(firebaseConfig);
      const auth = getAuth(app);
      const db = getFirestore(app);

      // --- Game Constants ---
      const CONST = {
          MAX_MOVE_HISTORY: 6,
          USER_TAG_LENGTH: 5,
          ROOM_CODE_LENGTH: 4,
          CONNECTION_TIMEOUT: 15000, // 15 seconds
          REWARDS: { WIN: 200, LOSS: 100, DRAW: 50 },
          MEDALS: {
              WS_5: { id: "ws_5", name: "‡∏£‡πâ‡∏≠‡∏ô‡πÅ‡∏£‡∏á! üî•", description: "‡∏ä‡∏ô‡∏∞‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ô 5 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á" }
          }
      };

      const SHOP_ITEMS = {
           'symbol_default': { name: '‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô', type: 'symbol', value: 'X', price: 0, default: true },
           'symbol_sword': { name: '‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏î‡∏≤‡∏ö‡πÑ‡∏Ç‡∏ß‡πâ', type: 'symbol', value: '‚öîÔ∏è', price: 500 },
           'symbol_ghost': { name: '‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏ú‡∏µ‡∏ô‡πâ‡∏≠‡∏¢', type: 'symbol', value: 'üëª', price: 500 },
           'symbol_heart': { name: '‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏´‡∏±‡∏ß‡πÉ‡∏à', type: 'symbol', value: '‚ù§Ô∏è', price: 750 },
           'symbol_star': { name: '‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå‡∏î‡∏≤‡∏ß', type: 'symbol', value: '‚≠ê', price: 750 },
      };
     
      // --- Audio & Animation ---
      let audioCtx;
      const confettiCanvas = document.getElementById('confetti-canvas');
      const confettiCtx = confettiCanvas.getContext('2d');
      let confettiParticles = [];
      const confettiColors = ['#ef4444', '#3b82f6', '#22c55e', '#f97316', '#eab308'];
      let animationFrameId;
      const GRAVITY = 0.08;
      const DAMPING = 0.99;
      const PARTICLE_COUNT = 150;

      const playPopSound = () => {
          if (!audioCtx) return;
          const oscillator = audioCtx.createOscillator();
          const gainNode = audioCtx.createGain();
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
          gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
          oscillator.connect(gainNode);
          gainNode.connect(audioCtx.destination);
          oscillator.start();
          oscillator.stop(audioCtx.currentTime + 0.3);
      };

      const initializeAudio = () => {
          if (!audioCtx) {
              audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          }
      };
      document.body.addEventListener('click', initializeAudio, { once: true });
     
      function resizeCanvas() {
          if (!confettiCanvas) return;
          confettiCanvas.width = window.innerWidth;
          confettiCanvas.height = window.innerHeight;
      }
      window.addEventListener('resize', resizeCanvas);

      function createConfetti(origin) {
          const { width, height } = confettiCanvas;
          for (let i = 0; i < PARTICLE_COUNT; i++) {
              const angle = Math.random() * Math.PI * 2;
              const speed = Math.random() * 8 + 2;
              confettiParticles.push({
                  x: origin.x,
                  y: origin.y,
                  isCircle: Math.random() > 0.5,
                  size: Math.random() * 8 + 4,
                  color: confettiColors[Math.floor(Math.random() * confettiColors.length)],
                  vx: Math.cos(angle) * speed,
                  vy: Math.sin(angle) * speed - 2,
                  angle: Math.random() * Math.PI * 2,
                  spin: Math.random() * 0.2 - 0.1,
                  opacity: 1,
              });
          }
      }

      function drawConfetti() {
          if (!confettiCtx) return;
          confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
          confettiParticles.forEach((p, i) => {
              p.vy += GRAVITY;
              p.vx *= DAMPING;
              p.x += p.vx;
              p.y += p.vy;
              p.angle += p.spin;
              p.opacity -= 0.007;

              if (p.opacity <= 0) {
                  confettiParticles.splice(i, 1);
                  return;
              }

              confettiCtx.save();
              confettiCtx.globalAlpha = p.opacity;
              confettiCtx.translate(p.x, p.y);
              confettiCtx.rotate(p.angle);
              confettiCtx.fillStyle = p.color;
             
              if (p.isCircle) {
                  confettiCtx.beginPath();
                  confettiCtx.arc(0, 0, p.size / 2, 0, Math.PI * 2);
                  confettiCtx.fill();
              } else {
                  confettiCtx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
              }
             
              confettiCtx.restore();
          });
      }

      function animateConfetti() {
          if (confettiParticles.length > 0) {
              drawConfetti();
              animationFrameId = requestAnimationFrame(animateConfetti);
          } else {
              if(confettiCtx) confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
              cancelAnimationFrame(animationFrameId);
          }
      }

      function startConfetti(origin) {
          resizeCanvas();
          confettiParticles = [];
          createConfetti(origin);
          if (animationFrameId) cancelAnimationFrame(animationFrameId);
          animateConfetti();
      }

      // --- App State ---
      let AppState = {
          currentUser: { uid: null, username: null, userTag: null, stats: { wins: 0, losses: 0 }, coins: 0, medals: [], winStreak: 0, lossStreak: 0, inventory: ['symbol_default'], equipped: { symbol: 'symbol_default' } },
          currentRoom: { id: null, data: null, countdownInterval: null },
          playerSymbol: '',
          listeners: { room: null, user: null },
          game: { state: Array(9).fill(""), history: [], currentPlayer: "X", isActive: false, mode: 'bot', playerSymbols: { X: 'X', O: 'O' } },
          loadingTimeout: null,
      };

      // --- DOM Elements ---
      const DOM = {
          screens: {
              mainMenu: document.getElementById('main-menu'),
              settings: document.getElementById('settings-screen'),
              shop: document.getElementById('shop-screen'),
              coopMenu: document.getElementById('coop-menu'),
              roomLobby: document.getElementById('room-lobby'),
              game: document.getElementById('game-screen'),
          },
          modals: {
              profile: document.getElementById('profile-modal'),
          },
          contextMenu: document.getElementById('context-menu'),
          gameBoard: document.getElementById('game-board'),
          winningLineContainer: document.getElementById('winning-line-container'),
          turnDisplay: document.getElementById('turn-display'),
      };

      // --- Utility Functions ---
      const showToast = (message, type = 'info') => {
          const toast = document.getElementById('toast-notification');
          const toastMessage = document.getElementById('toast-message');
          toastMessage.textContent = message;
          toast.className = `fixed top-5 right-5 text-white px-6 py-3 rounded-lg shadow-lg transition-all duration-300 z-50 opacity-100 transform translate-y-0 ${type === 'error' ? 'bg-red-600' : 'bg-gray-800'}`;
          setTimeout(() => {
              toast.classList.replace('opacity-100', 'opacity-0');
              toast.classList.replace('translate-y-0', '-translate-y-10');
          }, 3000);
      };
     
      const showErrorScreen = (show = true) => {
          const errorOverlay = document.getElementById('connection-error-overlay');
          if (show) {
              document.getElementById('loading-overlay').style.display = 'none';
              errorOverlay.style.display = 'flex';
          } else {
              errorOverlay.style.display = 'none';
          }
      };

      const showScreen = (screenName) => {
          Object.values(DOM.screens).forEach(s => s.classList.remove('active'));
          if(DOM.screens[screenName]) DOM.screens[screenName].classList.add('active');
      };

      const showModal = (modalName, show = true) => {
          if(DOM.modals[modalName]) DOM.modals[modalName].classList.toggle('active', show);
      };

      const generateRandomName = () => {
          const randomNumber = Math.floor(1000 + Math.random() * 9000);
          return `Player${randomNumber}`;
      };
     
      // --- Initialization ---
      const init = () => {
          addEventListeners();
         
          AppState.loadingTimeout = setTimeout(() => {
              console.error("Connection timed out.");
              showErrorScreen(true);
          }, CONST.CONNECTION_TIMEOUT);

          onAuthStateChanged(auth, async (user) => {
              try {
                  if (!user) {
                      await signInAnonymously(auth);
                      return;
                  }
                  AppState.currentUser.uid = user.uid;
                  await checkUserRegistration();
                  clearTimeout(AppState.loadingTimeout);
              } catch (e) {
                  console.error("Error during authentication or user setup:", e);
                  clearTimeout(AppState.loadingTimeout);
                  showErrorScreen(true);
              }
          });
      };
     
      // --- User & Profile Management ---
      const checkUserRegistration = async () => {
          const loadingOverlay = document.getElementById('loading-overlay');
          const userRef = doc(db, "users", AppState.currentUser.uid);
          const userSnap = await getDoc(userRef);

          if (userSnap.exists()) {
              const userData = userSnap.data();
               // Merge, ensuring defaults for new fields like inventory
               AppState.currentUser = { ...AppState.currentUser, ...userData };
          } else {
              const newUsername = generateRandomName();
              const userTag = AppState.currentUser.uid.substring(0, CONST.USER_TAG_LENGTH);
              const newUserData = {
                  username: newUsername,
                  userTag: userTag,
                  stats: { wins: 0, losses: 0 },
                  coins: 0,
                  winStreak: 0,
                  lossStreak: 0,
                  medals: [],
                  inventory: ['symbol_default'],
                  equipped: { symbol: 'symbol_default' },
                  createdAt: serverTimestamp()
              };
              await setDoc(userRef, newUserData);
              AppState.currentUser = { ...AppState.currentUser, ...newUserData };
          }
           updateWelcomeUI();
           listenToUserUpdates();
           showScreen('mainMenu');
           loadingOverlay.style.opacity = '0';
           setTimeout(() => { loadingOverlay.style.display = 'none'; }, 300);
      };

      function updateWelcomeUI() {
          document.getElementById('welcome-message').innerText = `‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏ï‡πâ‡∏≠‡∏ô‡∏£‡∏±‡∏ö, ${AppState.currentUser.username}#${AppState.currentUser.userTag}`;
          document.getElementById('user-coins').innerText = AppState.currentUser.coins || 0;
          document.getElementById('shop-user-coins').innerText = AppState.currentUser.coins || 0;
      }
   
      const listenToUserUpdates = () => {
          if(AppState.listeners.user) AppState.listeners.user();
          const userRef = doc(db, "users", AppState.currentUser.uid);
          AppState.listeners.user = onSnapshot(userRef, (docSnap) => {
              if (docSnap.exists()) {
                  AppState.currentUser = { ...AppState.currentUser, ...docSnap.data() };
                  updateWelcomeUI();
              }
          });
      }

      async function handleSaveUsername() {
          const input = document.getElementById('change-username-input');
          const errorP = document.getElementById('change-username-error');
          const newUsername = input.value.trim();
          const usernameRegex = /^[a-zA-Z0-9]+$/;

          errorP.textContent = '';
          if (newUsername.length < 3 || newUsername.length > 12) {
              errorP.textContent = '‡∏ä‡∏∑‡πà‡∏≠‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ 3-12 ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£';
              return;
          }
          if (!usernameRegex.test(newUsername)) {
              errorP.textContent = '‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡∏≠‡∏±‡∏á‡∏Å‡∏§‡∏©‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô';
              return;
          }
          if (newUsername === AppState.currentUser.username) {
              showToast('‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°');
              showScreen('mainMenu');
              return;
          }

          try {
              await updateDoc(doc(db, "users", AppState.currentUser.uid), { username: newUsername });
              showToast('‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!');
              updateWelcomeUI();
              showScreen('mainMenu');
          } catch (error) {
              console.error("Error saving username: ", error);
              showToast("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ä‡∏∑‡πà‡∏≠", 'error');
              errorP.textContent = '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà';
          }
      }

      // --- Friend Management ---
      async function handleSearchUsers() {
          const searchTerm = document.getElementById('search-user-input').value.trim();
          const resultsDiv = document.getElementById('search-results');
          resultsDiv.innerHTML = '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤...';

          if (searchTerm.length < 1) {
              resultsDiv.innerHTML = '<p class="text-gray-500">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏û‡∏¥‡∏°‡∏û‡πå‡∏ä‡∏∑‡πà‡∏≠‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤</p>';
              return;
          }

          const q = query(collection(db, "users"), where("username", "==", searchTerm));
          const querySnapshot = await getDocs(q);

          if (querySnapshot.empty) {
              resultsDiv.innerHTML = '<p class="text-gray-500">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô</p>';
          } else {
              resultsDiv.innerHTML = '';
              querySnapshot.forEach(docSnap => {
                  const user = docSnap.data();
                  const uid = docSnap.id;
                  if (uid === AppState.currentUser.uid) return;

                  const userDiv = document.createElement('div');
                  userDiv.className = 'flex justify-between items-center p-2 bg-gray-100 rounded-md mb-1';
                 
                  const friendStatus = AppState.currentUser.friends ? AppState.currentUser.friends[uid] : null;
                  let buttonHtml = '';
                  if (friendStatus === 'accepted') {
                      buttonHtml = '<span class="text-green-500">‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡∏Å‡∏±‡∏ô‡πÅ‡∏•‡πâ‡∏ß</span>';
                  } else if (friendStatus === 'pending_sent') {
                      buttonHtml = '<span class="text-gray-500">‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏Ç‡∏≠‡πÅ‡∏•‡πâ‡∏ß</span>';
                  } else if (friendStatus === 'pending_received') {
                      buttonHtml = `<button data-uid="${uid}" class="accept-friend-btn button button-success !py-1 !px-3 !my-0 !text-sm">‡∏£‡∏±‡∏ö</button>`;
                  } else {
                      buttonHtml = `<button data-uid="${uid}" class="add-friend-btn button button-primary !py-1 !px-3 !my-0 !text-sm">‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô</button>`;
                  }

                  userDiv.innerHTML = `<span>${user.username}#${user.userTag}</span> ${buttonHtml}`;
                  resultsDiv.appendChild(userDiv);
              });
          }
      }

      async function sendFriendRequest(targetUid) {
          const batch = writeBatch(db);
          batch.update(doc(db, "users", AppState.currentUser.uid), { [`friends.${targetUid}`]: 'pending_sent' });
          batch.update(doc(db, "users", targetUid), { [`friends.${AppState.currentUser.uid}`]: 'pending_received' });
          await batch.commit();
          showToast('‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏Ç‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡πÅ‡∏•‡πâ‡∏ß!');
          handleSearchUsers();
      }

      async function acceptFriendRequest(targetUid) {
          const batch = writeBatch(db);
          batch.update(doc(db, "users", AppState.currentUser.uid), { [`friends.${targetUid}`]: 'accepted' });
          batch.update(doc(db, "users", targetUid), { [`friends.${AppState.currentUser.uid}`]: 'accepted' });
          await batch.commit();
          showToast('‡∏£‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô‡πÅ‡∏•‡πâ‡∏ß!');
      }

      async function updateFriendsUI() {
          const requestsList = document.getElementById('friend-requests-list');
          const friendsList = document.getElementById('friends-list');
         
          const friendUIDs = Object.keys(AppState.currentUser.friends || {});
          if (friendUIDs.length === 0) {
              requestsList.innerHTML = '<p class="text-gray-500">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏≥‡∏Ç‡∏≠</p>';
              friendsList.innerHTML = '<p class="text-gray-500">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô</p>';
              return;
          }

          const friendPromises = friendUIDs.map(uid => getDoc(doc(db, "users", uid)));
          const friendDocs = await Promise.all(friendPromises);

          let requestsHTML = '';
          let friendsHTML = '';

          friendDocs.forEach(docSnap => {
              if (!docSnap.exists()) return;
              const user = docSnap.data();
              const uid = docSnap.id;
              const status = AppState.currentUser.friends[uid];
              const displayName = `${user.username}#${user.userTag}`;

              if (status === 'pending_received') {
                  requestsHTML += `<div class="flex justify-between items-center p-2"><span>${displayName}</span><button data-uid="${uid}" class="accept-friend-btn button button-success !py-1 !px-3 !my-0 !text-sm">‡∏£‡∏±‡∏ö</button></div>`;
              } else if (status === 'accepted') {
                  friendsHTML += `<div class="p-2">${displayName}</div>`;
              }
          });

          requestsList.innerHTML = requestsHTML || '<p class="text-gray-500">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏≥‡∏Ç‡∏≠</p>';
          friendsList.innerHTML = friendsHTML || '<p class="text-gray-500">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô</p>';
      }
     
      async function viewProfile(uid) {
          const userSnap = await getDoc(doc(db, 'users', uid));
          if (userSnap.exists()) {
              const user = userSnap.data();
              document.getElementById('profile-username').textContent = `${user.username}#${user.userTag}`;
              document.getElementById('profile-coins').textContent = user.coins || 0;
              document.getElementById('profile-wins').textContent = user.stats?.wins || 0;
              document.getElementById('profile-losses').textContent = user.stats?.losses || 0;

              const medalsList = document.getElementById('profile-medals-list');
              if (user.medals && user.medals.length > 0) {
                  medalsList.innerHTML = '';
                  user.medals.forEach(medalId => {
                      const medalInfo = CONST.MEDALS[medalId.toUpperCase()];
                      if (medalInfo) {
                          const medalDiv = document.createElement('div');
                          medalDiv.className = 'inline-block bg-gray-100 rounded-lg px-3 py-1 m-1';
                          medalDiv.textContent = medalInfo.name;
                          medalsList.appendChild(medalDiv);
                      }
                  });
              } else {
                  medalsList.innerHTML = '<p class="text-gray-500">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡∏£‡∏≤‡∏á‡∏ß‡∏±‡∏•</p>';
              }

              showModal('profile', true);
          }
      }

      // --- Shop Logic ---
      function renderShop() {
          const grid = document.getElementById('shop-items-grid');
          grid.innerHTML = '';
          const { inventory, equipped, coins } = AppState.currentUser;

          Object.entries(SHOP_ITEMS).forEach(([id, item]) => {
               if(item.default && id !== equipped.symbol) return; // Hide default unless equipped

              const isOwned = inventory.includes(id);
              const isEquipped = equipped.symbol === id;

              const card = document.createElement('div');
              card.className = 'bg-white rounded-lg shadow-md p-4 flex flex-col items-center text-center relative';
             
              let buttonHtml;
              if (isEquipped) {
                  buttonHtml = `<button class="button button-success !text-sm !py-1 !px-4 mt-2" disabled>‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà</button>`;
              } else if (isOwned) {
                  buttonHtml = `<button data-item-id="${id}" class="equip-item-btn button button-primary !text-sm !py-1 !px-4 mt-2">‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô</button>`;
              } else {
                  buttonHtml = `<button data-item-id="${id}" class="buy-item-btn button button-warning !text-sm !py-1 !px-4 mt-2" ${coins < item.price ? 'disabled' : ''}>üí∞ ${item.price}</button>`;
              }

              card.innerHTML = `
                  <div class="text-5xl mb-2">${item.value}</div>
                  <h4 class="font-semibold text-gray-700">${item.name}</h4>
                  ${buttonHtml}
              `;
              grid.appendChild(card);
          });
      }

      async function handleBuyItem(itemId) {
           const item = SHOP_ITEMS[itemId];
           if (!item) return;

           await runTransaction(db, async (transaction) => {
               const userRef = doc(db, "users", AppState.currentUser.uid);
               const userDoc = await transaction.get(userRef);
               if (!userDoc.exists()) throw "User does not exist!";

               const userData = userDoc.data();
               if (userData.coins < item.price) throw "Not enough coins!";
               if (userData.inventory.includes(itemId)) throw "Item already owned!";

               transaction.update(userRef, {
                   coins: increment(-item.price),
                   inventory: arrayUnion(itemId)
               });
           }).then(() => {
               showToast(`‡∏ã‡∏∑‡πâ‡∏≠ ${item.name} ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!`);
               renderShop();
           }).catch((error) => {
               console.error("Buy item transaction failed: ", error);
               showToast(`‡∏ã‡∏∑‡πâ‡∏≠‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: ${error}`, 'error');
           });
      }

      async function handleEquipItem(itemId) {
           const item = SHOP_ITEMS[itemId];
           if (!item || !AppState.currentUser.inventory.includes(itemId)) return;
           
           try {
               await updateDoc(doc(db, "users", AppState.currentUser.uid), {
                   'equipped.symbol': itemId
               });
               showToast(`‡∏™‡∏ß‡∏°‡πÉ‡∏™‡πà ${item.name} ‡πÅ‡∏•‡πâ‡∏ß!`);
               renderShop();
           } catch (error) {
               console.error("Error equipping item: ", error);
               showToast("‡∏™‡∏ß‡∏°‡πÉ‡∏™‡πà‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à", 'error');
           }
      }
     
      // --- Game Logic ---
      function startGame() {
          document.getElementById('game-screen-over-overlay').classList.add('hidden');
          document.getElementById('game-screen-over-overlay').classList.remove('flex');
          document.getElementById('leave-game-btn').style.display = 'flex';
          document.getElementById('rematch-btn').disabled = false;
          document.getElementById('rematch-status').textContent = '';

          AppState.game.state.fill("");
          AppState.game.history = [];
          AppState.game.isActive = true;
         
          if (AppState.game.mode === 'bot') {
              const playerStarts = Math.random() < 0.5;
              AppState.game.currentPlayer = playerStarts ? 'X' : 'O';
              const playerEquippedSymbol = SHOP_ITEMS[AppState.currentUser.equipped.symbol]?.value || 'X';
              AppState.game.playerSymbols = { X: playerEquippedSymbol, O: 'O' };
          } else { // coop
              AppState.game.currentPlayer = "X";
              const roomPlayers = AppState.currentRoom.data.players;
              const playerX = Object.values(roomPlayers).find(p => p.symbol === 'X');
              const playerO = Object.values(roomPlayers).find(p => p.symbol === 'O');
              AppState.game.playerSymbols = {
                  X: SHOP_ITEMS[playerX.equippedSymbol]?.value || 'X',
                  O: SHOP_ITEMS[playerO.equippedSymbol]?.value || 'O'
              };
          }

          DOM.winningLineContainer.innerHTML = '';
          DOM.gameBoard.innerHTML = '';
          for (let i = 0; i < 9; i++) {
              const cell = document.createElement('div');
              cell.classList.add('cell');
              cell.dataset.index = i;
              cell.onclick = handleCellClick;
              DOM.gameBoard.appendChild(cell);
          }
          showScreen('game');
          updateTurnDisplay();
          if (AppState.game.mode === 'bot' && AppState.game.currentPlayer === 'O') setTimeout(botMove, 500);
      }

      function handleCellClick(event) {
          playPopSound();
          if (!AppState.game.isActive) return;
          const index = parseInt(event.target.dataset.index);

          if (AppState.game.mode === 'bot') {
              if (AppState.game.state[index] !== "" || AppState.game.currentPlayer !== 'X') return;
              makeMove(index);
              if (AppState.game.isActive) setTimeout(botMove, 500);
          } else if (AppState.game.mode === 'coop') {
              if (AppState.game.currentPlayer !== AppState.playerSymbol || AppState.game.state[index] !== "") return;
             
              let newBoard = [...AppState.game.state];
              let newHistory = [...AppState.game.history];
              if (newHistory.length >= CONST.MAX_MOVE_HISTORY) {
                  const oldestMove = newHistory.shift();
                  newBoard[oldestMove.index] = "";
              }
              newBoard[index] = AppState.game.currentPlayer;
              newHistory.push({ player: AppState.game.currentPlayer, index: index });
              const nextTurn = AppState.game.currentPlayer === 'X' ? 'O' : 'X';
             
              const roomRef = doc(db, "rooms", AppState.currentRoom.id);
              const winnerResult = checkWinner(newBoard);
             
              updateDoc(roomRef, {
                  "game.board": newBoard,
                  "game.history": newHistory,
                  "game.turn": nextTurn,
                  "game.winner": winnerResult ? winnerResult.winner : null,
                  "status": winnerResult || newBoard.filter(c => c).length === 9 ? 'finished' : 'playing'
              });
          }
      }
     
      async function makeMove(index) {
          if (AppState.game.state[index] !== "" || !AppState.game.isActive) return;
         
          if (AppState.game.history.length >= CONST.MAX_MOVE_HISTORY) {
              const oldestMove = AppState.game.history.shift();
              AppState.game.state[oldestMove.index] = "";
          }
         
          AppState.game.state[index] = AppState.game.currentPlayer;
          AppState.game.history.push({ player: AppState.game.currentPlayer, index: index });
          updateBoardUI();
         
          const result = checkWinner(AppState.game.state);
          if (result) {
              endGame(false, result.winner, result);
          } else if (!AppState.game.state.includes("")) {
               endGame(true);
          } else {
              AppState.game.currentPlayer = AppState.game.currentPlayer === 'X' ? 'O' : 'X';
              updateTurnDisplay();
          }
      }

      function updateBoardUI() {
          document.querySelectorAll('.cell.indicate-fade').forEach(c => c.classList.remove('indicate-fade'));
          AppState.game.state.forEach((value, i) => {
              const cell = document.querySelector(`.cell[data-index='${i}']`);
              const displaySymbol = value ? AppState.game.playerSymbols[value] : '';
              if (cell && cell.innerText !== displaySymbol) {
                  cell.innerText = displaySymbol;
                  cell.className = 'cell ' + (value ? value.toLowerCase() : '');
              } else if (cell && !value && cell.innerText) {
                   cell.innerText = '';
                   cell.className = 'cell';
              }
          });
          if(AppState.game.history.length >= CONST.MAX_MOVE_HISTORY) {
              const nextToFadeIndex = AppState.game.history[0].index;
              const cellToIndicate = document.querySelector(`.cell[data-index='${nextToFadeIndex}']`);
              if (cellToIndicate) cellToIndicate.classList.add('indicate-fade');
          }
      }
     
      function updateTurnDisplay() {
          if (!AppState.game.isActive) {
              DOM.turnDisplay.innerText = '';
              return;
          }
          const displaySymbol = AppState.game.playerSymbols[AppState.game.currentPlayer];
          if (AppState.game.mode === 'coop') {
              DOM.turnDisplay.innerText = (AppState.game.currentPlayer === AppState.playerSymbol) ? "‡∏ï‡∏≤‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì!" : `‡∏£‡∏≠‡∏ï‡∏≤‡∏Ç‡∏≠‡∏á‡∏ù‡πà‡∏≤‡∏¢‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏° (${displaySymbol})`;
          } else {
              DOM.turnDisplay.innerText = AppState.game.currentPlayer === 'X' ? `‡∏ï‡∏≤‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì (${displaySymbol})` : `‡∏ï‡∏≤‡∏Ç‡∏≠‡∏á‡∏ö‡∏≠‡∏ó (${displaySymbol})`;
          }
      }

      function checkWinner(board) {
          const lines = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
          for (const line of lines) {
              const [a, b, c] = line;
              if (board[a] && board[a] === board[b] && board[a] === board[c]) return { winner: board[a], line: line };
          }
          return null;
      }

      function drawWinningLine(result) {
          const lineDiv = document.createElement('div');
          lineDiv.className = 'winning-line';
         
          const line = result.line;
          const boardSize = DOM.gameBoard.offsetWidth;
          const cellSize = boardSize / 3;
          let angle = 0; let top = 0; let left = 0; let width = boardSize;
          const lineHeightOffset = 6;

          if (line[0] === 0 && line[2] === 2) { top = (cellSize * 0.5) - lineHeightOffset; }
          else if (line[0] === 3 && line[2] === 5) { top = (cellSize * 1.5) - lineHeightOffset; }
          else if (line[0] === 6 && line[2] === 8) { top = (cellSize * 2.5) - lineHeightOffset; }
          else if (line[0] === 0 && line[2] === 6) { top = (boardSize / 2); left = (cellSize * 0.5) - (boardSize / 2); angle = 90; }
          else if (line[0] === 1 && line[2] === 7) { top = (boardSize / 2); left = (cellSize * 1.5) - (boardSize / 2); angle = 90; }
          else if (line[0] === 2 && line[2] === 8) { top = (boardSize / 2); left = (cellSize * 2.5) - (boardSize / 2); angle = 90; }
          else if (line[0] === 0 && line[2] === 8) { top = 0; left = 0; angle = 45; width = boardSize * 1.414; lineDiv.style.transformOrigin = 'top left'; }
          else if (line[0] === 2 && line[2] === 6) { top = boardSize; left = 0; angle = -45; width = boardSize * 1.414; lineDiv.style.transformOrigin = 'bottom left'; }

          lineDiv.style.setProperty('--line-width', `${width}px`);
          lineDiv.style.transform = `translate(${left}px, ${top}px) rotate(${angle}deg)`;
          DOM.winningLineContainer.appendChild(lineDiv);
      }

      async function endGame(isDraw, winner = null, result = null) {
          AppState.game.isActive = false;
          document.getElementById('leave-game-btn').style.display = 'none';
         
          const overlay = document.getElementById('game-screen-over-overlay');
          const message = document.getElementById('game-over-message');
          const coinRewardEl = document.getElementById('game-coin-reward');
          const medalRewardEl = document.getElementById('game-medal-reward');
          coinRewardEl.textContent = '';
          medalRewardEl.textContent = '';

          let coinsEarned = 0;
          let newMedal = null;
          let playerWon = false;
         
          if (isDraw) {
              message.innerText = "‡πÄ‡∏™‡∏°‡∏≠!";
              coinsEarned = CONST.REWARDS.DRAW;
          } else {
              playerWon = (AppState.game.mode === 'bot' && winner === 'X') || (AppState.game.mode === 'coop' && winner === AppState.playerSymbol);
              message.innerText = playerWon ? "‡∏Ñ‡∏∏‡∏ì‡∏ä‡∏ô‡∏∞!" : "‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏û‡πâ";
              coinsEarned = playerWon ? CONST.REWARDS.WIN : CONST.REWARDS.LOSS;
              if(result) drawWinningLine(result);
          }
         
          coinRewardEl.textContent = `‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö ${coinsEarned} üí∞`;

           const hostUID = AppState.currentRoom.data ? Object.keys(AppState.currentRoom.data.players)[0] : AppState.currentUser.uid;
           
           // Only one player (host in coop, self in bot) updates stats
           if(AppState.currentUser.uid === hostUID) {
               let rewards;
               if (AppState.game.mode === 'coop') {
                   const winnerUID = Object.keys(AppState.currentRoom.data.players).find(uid => AppState.currentRoom.data.players[uid].symbol === winner);
                   const loserUID = Object.keys(AppState.currentRoom.data.players).find(uid => uid !== winnerUID);
                   rewards = await updatePostGameStats(winnerUID, isDraw ? null : loserUID, isDraw);
               } else { // Bot mode
                   const winnerUID = playerWon ? AppState.currentUser.uid : null;
                   const loserUID = playerWon ? null : AppState.currentUser.uid;
                   rewards = await updatePostGameStats(winnerUID, loserUID, isDraw);
               }
               
               if (rewards && rewards.newMedal && rewards.medalWinner === AppState.currentUser.uid) {
                   newMedal = rewards.newMedal;
               }
           }
         
          if (newMedal) {
              medalRewardEl.textContent = `‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ: ${CONST.MEDALS[newMedal.toUpperCase()].name}`;
          }

           // For coop games, set up rematch state
                     const rematchBtn = document.getElementById('rematch-btn');
           rematchBtn.style.display = 'flex'; // ‡πÅ‡∏™‡∏î‡∏á‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏™‡∏°‡∏≠
           
           // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÇ‡∏´‡∏°‡∏î‡∏≠‡∏≠‡∏ô‡πÑ‡∏•‡∏ô‡πå ‡πÉ‡∏´‡πâ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ rematch ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°
           if (AppState.game.mode === 'coop') {
               updateDoc(doc(db, "rooms", AppState.currentRoom.id), { 'game.rematch': {} });
           }

          setTimeout(() => {
              overlay.classList.remove('hidden');
              overlay.classList.add('flex');
              if (playerWon) {
                  const boardRect = DOM.gameBoard.getBoundingClientRect();
                  startConfetti({ x: boardRect.left + boardRect.width / 2, y: boardRect.top + boardRect.height / 2 });
              }
          }, 700);
      }

      // --- Bot Logic ---
      function botMove() {
          if (!AppState.game.isActive) return;
          makeMove(getBestBotMove());
      }
     
      function getBestBotMove() {
          const board = AppState.game.state;
          for (let i = 0; i < 9; i++) { if (board[i] === "") { let b = [...board]; b[i] = 'O'; if (checkWinner(b)) return i; } }
          for (let i = 0; i < 9; i++) { if (board[i] === "") { let b = [...board]; b[i] = 'X'; if (checkWinner(b)) return i; } }
          if (board[4] === 'O') {
              if ((board[0] === 'X' && board[8] === 'X') || (board[2] === 'X' && board[6] === 'X')) {
                  const sides = [1, 3, 5, 7].filter(i => board[i] === '');
                  if (sides.length > 0) return sides[Math.floor(Math.random() * sides.length)];
              }
          }
          if (board[4] === "") return 4;
          const cornerMap = { 0: 8, 2: 6, 6: 2, 8: 0 };
          for(const c in cornerMap) {
              if(board[c] === 'X' && board[cornerMap[parseInt(c)]] === '') {
                  return cornerMap[parseInt(c)];
              }
          }
          const corners = [0, 2, 6, 8].filter(i => board[i] === '');
          if (corners.length > 0) return corners[Math.floor(Math.random() * corners.length)];
          const sides = [1, 3, 5, 7].filter(i => board[i] === '');
          if (sides.length > 0) return sides[Math.floor(Math.random() * sides.length)];
          return board.findIndex(s => s === "");
      }

      // --- Online (Co-op) Logic ---
      async function handleCreateRoom(button) {
          button.disabled = true;
          button.innerHTML = '<span>‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á...</span>';
         
          const roomId = Math.random().toString(36).substring(2, 2 + CONST.ROOM_CODE_LENGTH).toUpperCase();
          const creatorSymbol = Math.random() < 0.5 ? 'X' : 'O';
          AppState.currentRoom.id = roomId;
          AppState.playerSymbol = creatorSymbol;
          const roomData = {
              status: 'lobby',
              players: {
                  [AppState.currentUser.uid]: {
                      username: AppState.currentUser.username,
                      userTag: AppState.currentUser.userTag,
                      symbol: creatorSymbol,
                      equippedSymbol: AppState.currentUser.equipped.symbol,
                      ready: false
                   }
              },
              game: { board: Array(9).fill(""), history: [], turn: "X", winner: null, rematch: {} },
              createdAt: serverTimestamp()
          };
          try {
              await setDoc(doc(db, "rooms", roomId), roomData);
              listenToRoomUpdates(roomId);
              showScreen('roomLobby');
          } catch (error) {
              console.error("Error creating room:", error);
              showToast("‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à", 'error');
          } finally {
              button.disabled = false;
              button.innerHTML = '<span>‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡πâ‡∏≠‡∏á</span>';
          }
      }

      async function handleJoinRoom() {
          const roomId = document.getElementById('room-code-input').value.trim().toUpperCase();
          if (!roomId) return showToast("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏™‡πà‡∏£‡∏´‡∏±‡∏™‡∏´‡πâ‡∏≠‡∏á", 'error');
         
          const roomRef = doc(db, "rooms", roomId);
         
          try {
           await runTransaction(db, async (transaction) => {
               const roomDoc = await transaction.get(roomRef);
               if (!roomDoc.exists()) throw "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ";
               
               const roomData = roomDoc.data();
               if (Object.keys(roomData.players).length >= 2) throw "‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏ï‡πá‡∏°‡πÅ‡∏•‡πâ‡∏ß";
               if (roomData.status !== 'lobby') throw "‡πÄ‡∏Å‡∏°‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß";
               if (roomData.players[AppState.currentUser.uid]) throw "‡∏Ñ‡∏∏‡∏ì‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡πâ‡∏ß";

               const existingPlayerSymbol = Object.values(roomData.players)[0].symbol;
               const joinerSymbol = existingPlayerSymbol === 'X' ? 'O' : 'X';

               AppState.currentRoom.id = roomId;
               AppState.playerSymbol = joinerSymbol;

               const newPlayerData = {
                   username: AppState.currentUser.username,
                   userTag: AppState.currentUser.userTag,
                   symbol: joinerSymbol,
                   equippedSymbol: AppState.currentUser.equipped.symbol,
                   ready: false
               };

               transaction.update(roomRef, { [`players.${AppState.currentUser.uid}`]: newPlayerData });
           });

           listenToRoomUpdates(roomId);
           showScreen('roomLobby');

          } catch (error) {
              showToast(error, 'error');
          }
      }

      function listenToRoomUpdates(roomId) {
          if (AppState.listeners.room) AppState.listeners.room();
          const roomRef = doc(db, "rooms", roomId);
          AppState.listeners.room = onSnapshot(roomRef, (docSnap) => {
              if (!docSnap.exists()) {
                  const activeScreenId = document.querySelector('.screen.active')?.id;
                  if (['roomLobby', 'game'].includes(activeScreenId)) {
                      showToast("‡∏´‡πâ‡∏≠‡∏á‡∏ñ‡∏π‡∏Å‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß", 'info');
                      cleanupAfterRoom();
                  }
                  return;
              }
              const roomData = docSnap.data();
              const oldData = AppState.currentRoom.data;
              AppState.currentRoom.data = roomData;
             
               if (roomData.status === 'lobby' && oldData?.status !== 'lobby') {
                   showScreen('roomLobby');
                   document.getElementById('game-screen-over-overlay').classList.add('hidden');
                   document.getElementById('game-screen-over-overlay').classList.remove('flex');
               }
               
              if(roomData.status === 'lobby') updateLobbyUI(roomData);

              if (roomData.status === 'playing' && oldData?.status !== 'playing') {
                  AppState.game.mode = 'coop';
                  startGame();
              }

              if (roomData.game) {
                  if (JSON.stringify(AppState.game.state) !== JSON.stringify(roomData.game.board || [])) {
                      AppState.game.state = roomData.game.board || Array(9).fill("");
                      AppState.game.history = roomData.game.history || [];
                      updateBoardUI();
                  }
                 
                  if (AppState.game.currentPlayer !== roomData.game.turn) {
                      AppState.game.currentPlayer = roomData.game.turn;
                      updateTurnDisplay();
                  }
                 
                  if (roomData.status === 'finished' && AppState.game.isActive) {
                      const winnerResult = checkWinner(roomData.game.board);
                      if (winnerResult) {
                          endGame(false, winnerResult.winner, winnerResult);
                      } else {
                          endGame(true); // Draw
                      }
                  }
              }

              if (roomData.game?.rematch) {
                  updateRematchStatus(roomData.game.rematch);
              }
          }, (error) => {
              console.error("Room listener error:", error);
              showToast("‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏´‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏õ‡∏±‡∏ç‡∏´‡∏≤", "error");
              cleanupAfterRoom();
          });
      }
   
      function updateLobbyUI(data) {
         document.getElementById('room-code-display').innerText = AppState.currentRoom.id;
         const playerListDiv = document.getElementById('player-list');
         playerListDiv.innerHTML = '';
         const lobbyStatus = document.getElementById('lobby-status');
         const readyBtn = document.getElementById('ready-btn');

         let allReady = Object.keys(data.players).length === 2;
         Object.entries(data.players).forEach(([uid, p]) => {
             const displayName = `${p.username}#${p.userTag}`;
             const playerDiv = document.createElement('div');
             playerDiv.dataset.uid = uid;
             playerDiv.className = 'player-name-lobby cursor-pointer hover:bg-gray-100 p-1 rounded';
             const statusText = p.ready
                 ? '<span class="text-green-500 font-semibold">‡∏û‡∏£‡πâ‡∏≠‡∏°</span>'
                 : '<span class="text-red-500">‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°</span>';
             playerDiv.innerHTML = `<span>${displayName} (${p.symbol}) - ${statusText}</span>`;
             playerListDiv.appendChild(playerDiv);
             if (!p.ready) allReady = false;
         });
       
         if (!allReady && AppState.currentRoom.countdownInterval) {
              clearInterval(AppState.currentRoom.countdownInterval);
              AppState.currentRoom.countdownInterval = null;
              lobbyStatus.textContent = "‡∏£‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏Å‡∏î‡∏û‡∏£‡πâ‡∏≠‡∏°";
              readyBtn.style.display = 'flex';
         }

         if (allReady && !AppState.currentRoom.countdownInterval) {
              readyBtn.style.display = 'none';
              startLobbyCountdown();
         } else if (!allReady) {
              lobbyStatus.textContent = Object.keys(data.players).length === 2 ? "‡∏£‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏Å‡∏î‡∏û‡∏£‡πâ‡∏≠‡∏°" : "‡∏£‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏ô...";
         }
      }

     function startLobbyCountdown() {
          let countdown = 5;
          const lobbyStatus = document.getElementById('lobby-status');
          lobbyStatus.innerHTML = `‡πÄ‡∏Å‡∏°‡∏à‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏ô <span class="font-bold text-xl">${countdown}</span>`;

          AppState.currentRoom.countdownInterval = setInterval(() => {
              countdown--;
              if (countdown > 0) {
                  lobbyStatus.innerHTML = `‡πÄ‡∏Å‡∏°‡∏à‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏ô <span class="font-bold text-xl">${countdown}</span>`;
              } else {
                  clearInterval(AppState.currentRoom.countdownInterval);
                  AppState.currentRoom.countdownInterval = null;
                  lobbyStatus.textContent = "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°...";
                  if (Object.keys(AppState.currentRoom.data.players)[0] === AppState.currentUser.uid) {
                      const roomRef = doc(db, "rooms", AppState.currentRoom.id);
                      updateDoc(roomRef, { status: 'playing' });
                  }
              }
          }, 1000);
     }
   
      async function handleReadyClick() {
          if (!AppState.currentRoom.id || !AppState.currentRoom.data || AppState.currentRoom.countdownInterval) return;
          const currentReadyStatus = AppState.currentRoom.data.players[AppState.currentUser.uid]?.ready || false;
          await updateDoc(doc(db, "rooms", AppState.currentRoom.id), { [`players.${AppState.currentUser.uid}.ready`]: !currentReadyStatus });
      }

      async function handleLeaveRoom(button) {
          if (!AppState.currentRoom.id) return;
          if(button) button.disabled = true;
          const roomId = AppState.currentRoom.id;
          if (AppState.listeners.room) AppState.listeners.room();
          AppState.listeners.room = null;

          try {
              await runTransaction(db, async (transaction) => {
                  const roomRef = doc(db, "rooms", roomId);
                  const roomDoc = await transaction.get(roomRef);
                  if (!roomDoc.exists()) return;

                  const roomData = roomDoc.data();
                  const players = roomData.players;
                  const wasInGame = roomData.status === 'playing';
                  const opponentUID = Object.keys(players).find(uid => uid !== AppState.currentUser.uid);
                  delete players[AppState.currentUser.uid];

                  if (Object.keys(players).length > 0) {
                      let updates = { players };
                      if (wasInGame) {
                          updates['status'] = 'finished';
                          updates['game.winner'] = roomData.players[opponentUID].symbol;
                          // The winner will handle updating stats
                      }
                      transaction.update(roomRef, updates);
                  } else {
                      transaction.delete(roomRef);
                  }
              });
          } catch (error) {
              console.error("Error leaving room:", error);
          } finally {
              cleanupAfterRoom();
          }
      }

      function cleanupAfterRoom() {
          if (AppState.currentRoom.countdownInterval) {
              clearInterval(AppState.currentRoom.countdownInterval);
          }
          AppState.currentRoom = { id: null, data: null, countdownInterval: null };
          AppState.playerSymbol = '';
          showScreen('mainMenu');
         
          ['leave-room-btn', 'leave-game-btn', 'back-to-menu-from-game-btn', 'rematch-btn'].forEach(id => {
              const btn = document.getElementById(id);
              if (btn) btn.disabled = false;
          });
          document.getElementById('ready-btn').style.display = 'flex';
      }

      async function updatePostGameStats(winnerUID, loserUID, isDraw = false) {
          const batch = writeBatch(db);
          let newMedal = null;
          let medalWinner = null;

          if (isDraw) {
              // In coop, update both players for a draw
              if(AppState.game.mode === 'coop') {
                  const uids = Object.keys(AppState.currentRoom.data.players);
                  uids.forEach(uid => {
                      batch.update(doc(db, "users", uid), { coins: increment(CONST.REWARDS.DRAW), winStreak: 0, lossStreak: 0 });
                  });
              } else { // Bot mode draw
                  batch.update(doc(db, "users", AppState.currentUser.uid), { coins: increment(CONST.REWARDS.DRAW), winStreak: 0, lossStreak: 0 });
              }
          } else {
              const winnerRef = doc(db, "users", winnerUID);
              const loserRef = doc(db, "users", loserUID);
              const winnerDoc = await getDoc(winnerRef);
              const winnerData = winnerDoc.data();

              const newWinStreak = (winnerData.winStreak || 0) + 1;
              let winnerMedals = winnerData.medals || [];
              if (newWinStreak === 5 && !winnerMedals.includes(CONST.MEDALS.WS_5.id)) {
                  winnerMedals.push(CONST.MEDALS.WS_5.id);
                  newMedal = CONST.MEDALS.WS_5.id;
                  medalWinner = winnerUID;
              }

              batch.update(winnerRef, {
                  'stats.wins': increment(1),
                  coins: increment(CONST.REWARDS.WIN),
                  winStreak: increment(1),
                  lossStreak: 0,
                  medals: winnerMedals
              });

              batch.update(loserRef, {
                  'stats.losses': increment(1),
                  coins: increment(CONST.REWARDS.LOSS),
                  winStreak: 0,
                  lossStreak: increment(1)
              });
          }
          await batch.commit();
          return { newMedal, medalWinner };
      }
     
      async function handleRematchRequest(button) {
          if (!AppState.currentRoom.id) return;
          button.disabled = true;
          const roomRef = doc(db, "rooms", AppState.currentRoom.id);
          await updateDoc(roomRef, { [`game.rematch.${AppState.currentUser.uid}`]: true });
      }

      function updateRematchStatus(rematchData) {
          const rematchStatusEl = document.getElementById('rematch-status');
          const uids = Object.keys(AppState.currentRoom.data.players);
          if(uids.length < 2) return; // Opponent left
          const myUid = AppState.currentUser.uid;
          const opponentUid = uids.find(uid => uid !== myUid);

          if (rematchData[myUid] && rematchData[opponentUid]) {
               if (uids[0] === myUid) { // Host handles reset
                  const roomRef = doc(db, "rooms", AppState.currentRoom.id);
                  const players = AppState.currentRoom.data.players;
                  Object.keys(players).forEach(uid => { players[uid].ready = false; });
                 
                  // Swap symbols for the new game
                  const p1Symbol = players[uids[0]].symbol;
                  players[uids[0]].symbol = players[uids[1]].symbol;
                  players[uids[1]].symbol = p1Symbol;

                  updateDoc(roomRef, { status: "lobby", players: players, game: { board: Array(9).fill(""), history: [], turn: "X", winner: null, rematch: {} } });
              }
          } else if (rematchData[myUid]) {
              rematchStatusEl.textContent = "‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á ‡∏£‡∏≠‡∏≠‡∏µ‡∏Å‡∏ù‡πà‡∏≤‡∏¢...";
          } else if (rematchData[opponentUid]) {
              rematchStatusEl.textContent = "‡∏≠‡∏µ‡∏Å‡∏ù‡πà‡∏≤‡∏¢‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á!";
          } else {
              rematchStatusEl.textContent = "";
          }
      }
   
      // --- Event Listeners Setup ---
      function addEventListeners() {
          document.getElementById('play-bot-btn').onclick = () => { AppState.game.mode = 'bot'; startGame(); };
          document.getElementById('play-coop-btn').onclick = () => showScreen('coopMenu');
          document.getElementById('shop-btn').onclick = () => {
              renderShop();
              showScreen('shop');
          };
          document.getElementById('back-to-main-from-shop-btn').onclick = () => showScreen('mainMenu');
          document.getElementById('shop-items-grid').addEventListener('click', e => {
               if(e.target.closest('.buy-item-btn')) handleBuyItem(e.target.closest('.buy-item-btn').dataset.itemId);
               if(e.target.closest('.equip-item-btn')) handleEquipItem(e.target.closest('.equip-item-btn').dataset.itemId);
          });
          document.getElementById('settings-btn').onclick = () => {
              document.getElementById('change-username-input').value = AppState.currentUser.username;
              updateFriendsUI();
              showScreen('settings');
          };
          document.getElementById('back-to-main-from-settings-btn').onclick = () => showScreen('mainMenu');
          document.getElementById('back-to-main-from-coop-btn').onclick = () => showScreen('mainMenu');
          document.getElementById('save-settings-btn').onclick = handleSaveUsername;
          document.getElementById('search-user-btn').onclick = handleSearchUsers;
          document.getElementById('search-results').addEventListener('click', e => {
              if (e.target.closest('.add-friend-btn')) sendFriendRequest(e.target.closest('.add-friend-btn').dataset.uid);
              if (e.target.closest('.accept-friend-btn')) acceptFriendRequest(e.target.closest('.accept-friend-btn').dataset.uid);
          });
          document.getElementById('friend-requests-list').addEventListener('click', e => {
              if (e.target.closest('.accept-friend-btn')) acceptFriendRequest(e.target.closest('.accept-friend-btn').dataset.uid);
          });
          document.getElementById('create-room-btn').onclick = (e) => handleCreateRoom(e.currentTarget);
          document.getElementById('join-room-btn').onclick = handleJoinRoom;
          document.getElementById('ready-btn').onclick = handleReadyClick;
          document.getElementById('leave-room-btn').onclick = (e) => handleLeaveRoom(e.currentTarget);
          document.getElementById('copy-room-code-btn').onclick = () => {
              if (AppState.currentRoom.id) {
                  navigator.clipboard.writeText(AppState.currentRoom.id);
                  showToast('‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏£‡∏´‡∏±‡∏™‡∏´‡πâ‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß!');
              }
          };
          document.getElementById('leave-game-btn').onclick = (e) => {
              if (AppState.game.mode === 'coop') handleLeaveRoom(e.currentTarget);
              else showScreen('mainMenu');
          };
         
                    document.getElementById('rematch-btn').onclick = (e) => {
              if (AppState.game.mode === 'coop') {
                  // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏≠‡∏ô‡πÑ‡∏•‡∏ô‡πå ‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô rematch ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°
                  handleRematchRequest(e.currentTarget);
              } else {
                  // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏•‡πà‡∏ô‡∏Å‡∏±‡∏ö‡∏ö‡∏≠‡∏ó ‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô startGame() ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢
                  startGame();
              }
          };

          document.getElementById('back-to-menu-from-game-btn').onclick = (e) => {
               if (AppState.game.mode === 'coop' && AppState.currentRoom.id) handleLeaveRoom(e.currentTarget);
               else showScreen('mainMenu');
          };

          document.getElementById('close-profile-btn').onclick = () => showModal('profile', false);
          document.getElementById('player-list').addEventListener('click', (e) => {
              const playerDiv = e.target.closest('.player-name-lobby');
              if (playerDiv) {
                  e.stopPropagation();
                  const targetUid = playerDiv.dataset.uid;
                  const rect = playerDiv.getBoundingClientRect();
                  DOM.contextMenu.style.left = `${rect.left}px`;
                  DOM.contextMenu.style.top = `${rect.bottom + 5}px`;
                  DOM.contextMenu.style.display = 'block';
                  document.getElementById('view-profile-ctx-btn').dataset.uid = targetUid;
              }
          });
          document.getElementById('view-profile-ctx-btn').onclick = (e) => {
              const targetUid = e.currentTarget.dataset.uid;
              if (targetUid) viewProfile(targetUid);
              DOM.contextMenu.style.display = 'none';
          };
          document.addEventListener('click', (e) => {
              if (!e.target.closest('.context-menu') && !e.target.closest('.player-name-lobby')) {
                  DOM.contextMenu.style.display = 'none';
              }
          });
      }
     
      // --- Start the App ---
      init();
  </script>
</body>
</html>